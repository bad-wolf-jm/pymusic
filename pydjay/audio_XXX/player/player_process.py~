import os
#import re
#import mimetypes
import threading
#import socket
#import functools
#import json
import time
#import cPickle as pickle
#import array
import sys

#from functools import partial
#from threading import Thread
from os.path import getsize
from datetime import datetime

from kivy.clock import mainthread, Clock
#from kivy.lang import Builder
from kivy.properties import ObjectProperty, StringProperty, BooleanProperty, NumericProperty, AliasProperty
#from kivy.uix.boxlayout import BoxLayout
#from kivy.uix.bubble import Bubble
#from kivy.uix.popup import Popup
#from kivy.uix.button import Button

from kivy.properties import ObjectProperty
#from kivy.factory import Factory
from kivy.event import EventDispatcher
#from pydjay.audio.wavegen import WaveformGenerator
#from pydjay.audio.gst import AudioDecoder
#from pydjay.audio.remote import SlavePlayer

#from pydjay.library import save_to_current_session

#from pydjay.uix import waveform_seekbar#screen, paged_grid, paged_display
#from pydjay.gui.turntable import turntable
#from track_upload import UploadTrack
#from pydjay.gui.utils import seconds_to_human_readable
#from pydjay.utils.protocol import MAGIC
#from pydjay.uix import clickable_area
#from pydjay.uix import long_press_button
#from pydjay.uix.slider import XSlider

#from pydjay.gui.files_screen import file_browser, location_browser
#from mediacentre.skins.default.theme import get_path

#from kivy.logger import Logger
from decoder import GstAudioFile
from output_jack import JackOutput
from

class AudioPlayer(EventDispatcher):
    state                = StringProperty(None, allownone = True)
    track_duration       = NumericProperty(None, allownone = True)
    track_position       = NumericProperty(None, allownone = True)

    def __init__(self, player_name, num_channels = 2, *args, **kw):
        super(AudioPlayer, self).__init__(*args, **kw)
        self.register_event_type('on_end_of_stream')
        self._track_promise = None
        self._current_time  = None
        self._output        = JackOutput(player_name, num_channels)
        self._is_playing    = False
        self._player_thread = None
        self._decoder       = None
        
    def on_end_of_stream(self, *args):
        pass

    def connect_outputs(self, **kwargs):
        self._output.connect_outputs(**kwargs)

    def disconnect_outputs(self, **kwargs):
        self._output.disconnect_outputs(**kwargs)

    @mainthread
    def _signal_stream_time(self, timestamp):
        self.track_position = timestamp

    @mainthread
    def _signal_stream_duration(self, time):
        self.track_duration = time

    @mainthread
    def _signal_end_of_stream(self):
        self.dispatch('on_end_of_stream')
        self.stop()

    def _player_loop(self):
        if self._decoder is not None:
            while self._is_playing:
                try:
                    timestamp, samples = self._decoder.next()
                    self._signal_stream_time(timestamp)
                    if self._decoder.duration is not None:
                        self._signal_stream_duration(self._decoder.duration)
                    self._signal_stream_time(timestamp)
                    #print timestamp
                    self._output.send(samples)
                except StopIteration:
                    self._is_playing = False
                    self._signal_end_of_stream()
                    break

    def play(self, filename):
        self.stop()
        self._file          = filename
        self._decoder       = GstAudioFile(self._file, self._output.num_channels, self._output.samplerate)
        self._player_thread = threading.Thread(target = self._player_loop)
        self._is_playing    = True
        self._player_thread.start()
        self.state = "playing"

    def stop(self):
        self._is_playing = False
        if self._player_thread is not None:
            self._player_thread.join()
        self._player_thread = None
        self._decoder       = None
        self.track_duration = None
        self.track_position = None
        self.state          = "stopped"
        
    def pause(self):
        self.state = "paused"

    @property
    def is_playing(self):
        return self.state == 'playing'

buffer = []
if __name__ == '__main__':

    path = os.path.abspath(os.path.expanduser(sys.argv[1]))
    player = AudioPlayer("TestPlayer", 2)
    player.connect_outputs(output_1 = "system:playback_1",
                           output_2 = "system:playback_2")
    player.play(path)
    #time.sleep(45)
    #player.stop()
