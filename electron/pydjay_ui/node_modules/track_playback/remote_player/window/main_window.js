const path = require('path');
const { ipcRenderer } = require('electron');
const { PydjayAudioContext } = require("webaudio/audio_context.js")
const { PlaybackController } = require("./playback")


mpc = new PlaybackController() 

var response_prefix;
var parentId;

ipcRenderer.on('owner-class', (event, arg, win) => {
    response_prefix = arg
    parentId = win
});

ipcRenderer.on('play', (event, arg) => {        
    mpc.play(arg.track, arg.stream_start, arg.stream_end)
});

ipcRenderer.on('pause', (event, arg) => {        
    mpc.pause() 
});

ipcRenderer.on('resume', (event, arg) => {        
    mpc.resume() 

});

ipcRenderer.on('skip', (event, arg) => {        
    mpc.skip(arg.delta)

});

ipcRenderer.on('reset-audio-system', (event, arg) => {
    let audio_context =  new PydjayAudioContext()
    if (audio_context.audio_ctx.destination.maxChannelCount >= 6) {
        mpc.reset_audio_context(mpl_channel_config)
    } else {
        mpc.reset_audio_context(mpl_channel_config2)
    }
});

ipcRenderer.on('stop', (event, arg) => {        
    mpc.stop() 
});

ipcRenderer.on('togglePause', (event, arg) => {        
    mpc.togglePause() 
});

ipcRenderer.on('mute', (event, name) => {        
    mpc.muteOutput(name)
});

ipcRenderer.on('unmute', (event, name) => {        
    mpc.unmuteOutput(name)
});

ipcRenderer.on("init-outputs", (event, outputs) => {
    Object.keys(outputs).forEach((k) => {
        mpc.addOutput(k)
        mpc.setOutputDeviceId(k, outputs[k])
    })
})

ipcRenderer.on("add-output", (event, name) => {
    mpc.addOutput(name)
})


ipcRenderer.on("set-output-device-id", (event, name, deviceId) => {
    mpc.setOutputDeviceId(name, deviceId)
})