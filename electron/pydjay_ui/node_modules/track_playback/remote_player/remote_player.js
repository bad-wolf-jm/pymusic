
const { EventDispatcher } = require("notify/event_dispatcher.js")
const { BrowserWindow } = require("electron").remote
const { ipcRenderer } = require("electron")


class RemoteTrackPlayer extends EventDispatcher {
    constructor() {
        super()
        this._current_track = undefined
        this.remote = new BrowserWindow({width: 600, height: 400, show: false});
        this.response_prefix = this._id()
        this._initialized = false
        this._outputs = {}

        this.remote.loadURL('file://' + __dirname + '/window/index.html');

        ipcRenderer.on(`${this.response_prefix}end-of-stream`, (e, a) => {
            this.dispatch("end-of-stream")
        })

        ipcRenderer.on(`${this.response_prefix}playback-stopped`, (e, a) => {
            this.state = "STOPPED"
            this.dispatch("playback-stopped")
        })

        ipcRenderer.on(`${this.response_prefix}playback-paused`, (e, a) => {
            this.state = "PAUSED"
            this.dispatch("playback-paused")
        })

        ipcRenderer.on(`${this.response_prefix}playback-started`, (e, a) => {
            this.state = "PLAYING"
            this.dispatch("playback-started")
        })

        ipcRenderer.on(`${this.response_prefix}stream-position`, (e, a) => {
            this.dispatch("stream-position", a)
        })

        this.on("end-of-stream", () => {
            if (this._current_track != undefined) {
                this._current_track.end_time = new Date()
                this._current_track.status = "ended"
                this.dispatch("track-finished", this._current_track)
                this._current_track = undefined    
            }
        })
    }

    _id() {
        return '_' + Math.random().toString(36).substr(2, 9);
    };

    initialize() {
        if (!this._initialized) {
            this.remote.webContents.once("did-finish-load", () => {
                const currentWindow = require('electron').remote.getCurrentWindow();
                window.addEventListener("beforeunload", () => {
                    this.remote.close()
                })
                this.remote.webContents.send('owner-class', this.response_prefix, currentWindow.id)
                this.remote.webContents.send('init-outputs', this._outputs)
                this._initialized = true
            })
    
        }
    }

    addOutput(name) {
        if (this._initialized) {
            this.remote.webContents.send("add-output", name)
            this._outputs[name] = true
        } else {
            this._outputs[name] = "null"
        }
    }

    setOutputDeviceId(name, deviceId) {
        if (this._initialized && this._outputs[name]) {
            this.remote.webContents.send("set-output-device-id", name, deviceId)
            this._outputs[name] = deviceId
        } else {
            this._outputs[name] = deviceId
        }
    }

    getOutputDeviceIds() {
        return this._outputs
    }

    muteOutput(name) {
        this.remote.send("mute", name)
    }

    unmuteOutput(name) {
        this.remote.send("unmute", name)
    }

    play(track, stream_start, stream_end) {
        this._current_track = {
            track_object: track,
            start_time: new Date(),
            end_time: undefined,
            status: undefined
        }
        this.dispatch("track-started", this._current_track)
        this.remote.webContents.send("play", {
            track: track,
            stream_start: stream_start,
            stream_end: stream_end
        })
    }

    stop() {
        if (this._current_track != undefined) {
            this._current_track.end_time = new Date()
            this._current_track.status = "stopped"
            this.dispatch("track-stopped", this._current_track)
            this._current_track = undefined
        }
        this.remote.webContents.send("stop")
    }

    togglePause() {
        console.log("pause")
        this.remote.send("togglePause")
    }
}

module.exports = {
    RemoteTrackPlayer: RemoteTrackPlayer
}