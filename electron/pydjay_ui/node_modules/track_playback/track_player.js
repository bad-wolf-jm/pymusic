const {PydjayAudioFilePlayer} = require("webaudio/audio_player_file.js")

class AudioTrackPlayer extends PydjayAudioFilePlayer {
    constructor() {
        super()
        this._current_track = undefined
        this.on('end-of-stream', () => {
            if (this._current_track != undefined) {
                this._current_track.time_end = new Date()
                this._current_track.status = "ended"
                this.dispatch("track-finished", this._current_track)
                this._current_track = undefined    
            }
        })
    }

    reset_audio_context(channel_configuration) {
        let url = undefined,
            time = undefined,
            end_time = undefined;

        if (this.source != undefined) {
            time = this.source.currentTime * 1000
            end_time = this.stream_end
            url = this.url
            this.stop()
        }

        super.reset_audio_context()
        this.connectOutputs(channel_configuration)
        if (url != undefined) {
            super.play(url, time, end_time)
        }

        this.dispatch("audio-system-reset")
    }

    outputChannelCount() {
        return this.audio_context.audio_ctx.destination.maxChannelCount
    }

    play(track, stream_start, stream_end) {
        this._current_track = {
            track_object: track,
            time_start: new Date(),
            time_end: undefined,
            status: undefined
        }

        let file_name = path.join(track.music_root, track.file_name);

        if (stream_start == undefined) {
            stream_start = track.stream_start
            stream_end = track.stream_end
        } else if (stream_end == undefined) {
            stream_end = track.stream_end
            if (stream_start < 0) {
                stream_start = stream_end + stream_start;
            }
        }
        this.dispatch("track-started", this._current_track)
        super.play(file_name, stream_start / 1000000, stream_end / 1000000)
    }

    stop() {
        if (this._current_track != undefined) {
            this._current_track.time_end = new Date()
            this._current_track.status = "stopped"
            this.dispatch("track-stopped", this._current_track)
            this._current_track = undefined
        }
        super.stop()
    }

    addOutput(name) {
        this.audio_context.addOutput(name)
    }

    setOutputDeviceId(name, deviceId) {
        console.log(deviceId)
        if (deviceId == 'null') {            
            this.audio_context.outputs[name].pause()
        } else {
            this.audio_context.outputs[name].setSinkId(deviceId)
            this.audio_context.outputs[name].play()
        }
    }

}

module.exports = {
    AudioTrackPlayer: AudioTrackPlayer
}
