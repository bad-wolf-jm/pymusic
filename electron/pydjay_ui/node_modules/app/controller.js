const { EventDispatcher } = require("notify/event_dispatcher.js")
const { MusicDatabase } = require("musicdb/model.js")
const { RemoteTrackPlayer } = require("track_playback/remote_player/remote_player.js")

class PymusicAppController extends EventDispatcher {
    constructor() {
        super()
        this.library = new MusicDatabase("pymusic")
        this.setupMainPlayer()
        this.setupPrelistenPlayer()
        this.setupModelNotifiers()
    }

    setupModelNotifiers() {
        let dispatchUnavailable = async (trackIds) => {
            this.dispatch("library:unavailable-tracks-changed", 
                          await this.library.unavailable.getTrackIds())
        }
        this.library.queue.on("content-changed", async () => {
            dispatchUnavailable(await this.library.unavailable.getTrackIds())
            this.dispatch("queue:content-changed")
        })
        this.library.current_session.on("content-changed", async () => {
            dispatchUnavailable(await this.library.unavailable.getTrackIds())    
        })
        this.library.unavailable_tracks.on("content-changed", async () => {
            dispatchUnavailable(await this.library.unavailable.getTrackIds())    
        })
    }

    setupMainPlayer() {
        this.queue_playing = false
        this.main = new RemoteTrackPlayer()
        this.main.addOutput("master")
        this.main.addOutput("headset")
        this.setMasterOutputDeviceId('null')
        this.setHeadsetOutputDeviceId('null')
        this.main.initialize()

        let convertLogData = (log_data, status) => {return {
            status: status,
            time_start: log_data.start_time, 
            time_end: log_data.end_time
        }}

        let updateTrackPlayedStats = async (log_data) => {return {
            "stats.last_played": log_data.start_time,
            "stats.play_count": log_data.track_object.stats.play_count + 1
        }}

        this.main.on("track-started", async (log_data) => {
            await this.library.state.d.update({_id:"settings"}, {
                $set: {
                    "current_track._id": log_data._id
                }
            })
            this.dispatch("main:track-started", log_data)
        })
    
        this.main.on("track-finished", async (log_data) => {
            await this.library.current_session.append(
                log_data.track_object, 
                convertLogData(log_data, "FINISHED"))
            await this.library.tracks.setTrackMetadata(
                log_data.track_object, 
                updateTrackPlayedStats(log_data))
            let time = await this.library.state.d.find({_id: "settings"})
            let next_track = await this.library.queue.pop()
            if (next_track != undefined) {                
                this.playTrackAfterDelay(next_track, time.track_gap || 2000)
                this.dispatch("main:track-finished", log_data)
            } else {
                this.queue_playing = false
                this.dispatch("main:queue-finished")    
            }
        })
        
        this.main.on("track-stopped", async (log_data) => {
            await this.library.current_session.append(
                log_data.track_object, 
                convertLogData(log_data, "STOPPED"))
            await this.library.tracks.setTrackMetadata(
                log_data.track_object, 
                updateTrackPlayedStats(log_data))
            this.dispatch("main:track-stopped", log_data)
        })
    
        this.main.on("track-skipped", async (log_data) => {
            await this.library.current_session.append(
                log_data.track_object, 
                convertLogData(log_data, "SKIPPED"))
            await this.library.tracks.setTrackMetadata(
                log_data.track_object, 
                updateTrackPlayedStats(log_data))
            this.dispatch("main:track-skipped", log_data)
        })
    }

    setMasterOutputDeviceId(deviceId) {
        if (deviceId != this.getMasterOutputDeviceId()) {
            this.main.setOutputDeviceId("master", deviceId)
            this.dispatch("main:master-output-changed", deviceId)
        } 
    }

    setHeadsetOutputDeviceId(deviceId) {
        if (deviceId != this.getHeadsetOutputDeviceId()) {
            this.prelisten.setOutputDeviceId("headset", deviceId)        
            this.dispatch("main:headset-output-changed", deviceId)
        } 
    }

    getMasterOutputDeviceId() {
        return this.main.getOutputDeviceIds()['master']
    }

    getHeadsetOutputDeviceId() {
        return this.main.getOutputDeviceIds()['headset']
    }

    unmuteMasterHeadset() {
        this.main.unmuteOutput("headset")
    }

    muteMasterHeadset() {
        this.main.muteOutput("headset")
    }

    setupPrelistenPlayer() {
        this.prelisten = new RemoteTrackPlayer()   
        this.prelisten.addOutput("main")
        this.prelisten.setOutputDeviceId('main', 'null')
        this.prelisten.initialize()

        this.prelisten.on('playback-started', () => {
            this.muteMasterHeadset()
            this.dispatch("main:headset-muted")
            this.dispatch("prelisten:playback-started")
        })
        this.prelisten.on('playback-paused', () => {
            this.unmuteMasterHeadset()
            this.dispatch("main:headset-unmuted")
            this.dispatch("prelisten:playback-paused")
        })
        this.prelisten.on("track-started", (track) => {
            this.dispatch("prelisten:track-started", track)
        })
        this.prelisten.on("track-stopped", (track) => {
            this.dispatch("prelisten:track-stopped", track)
        })
        this.prelisten.on("track-finished", (track) => {
            this.dispatch("prelisten:track-finished", track)
        })
        this.prelisten.on("stream-position", (track) => {
            this.dispatch("prelisten:stream-position", track)
        })
    }

    setPrelistenOutputDeviceId(deviceId) {
        if (deviceId != this.prelisten.getOutputDeviceIds()['main']) {
            this.prelisten.setOutputDeviceId("main", deviceId)
            this.dispatch("prelisten:output-changed", deviceId)
        } 
    }

    getPrelistenOutputDeviceId() {
        return super.getOutputDeviceIds()["main"]
    }

    playTrackAfterDelay(track, delay) {
        let id = setInterval(() => {
            if (delay <= 0) {
                clearInterval(id);
                this.dispatch('main:next-track-countdown', 0)
                this.queue_playing = true
                this.dispatch("main:track-start-request", track)
    
            } else {
                this.dispatch('main:next-track-countdown', delay / 1000)
                delay = delay - 1000;
            }
        }, 1000)
    }

    async startQueue() {
        if (!this.queue_playing) {
            if (!(await this.library.queue.isEmpty())) {
                this.queue_playing = true
                this.dispatch("main:track-start-request", await this.library.queue.pop())
                this.dispatch("main:queue-started")
            }
        } 
    }

    stopQueue() {
        this.queue_playing = false;
        this.main.stop()
        this.dispatch("main:queue-stopped")
    }

    async skipToNextTrack() {
        if (this.queue_playing) {
            if (this._current_track != undefined) {
                this._current_track.end_time = new Date()
                this._current_track.status = "skipped"
                this.dispatch("main:track-skipped", this._current_track)
                this.stop()
                this._current_track = undefined    
            }
            if (!(await this.library.queue.isEmpty())) {
                this.dispatch("main:track-start-request", await this.library.queue.pop())
            }
        }
    }

    prelistenTrack(track, s) {
        this._prelisten_track = track
        if (track != undefined) {
            this.prelisten.play(track, (s != undefined) ? (s) : s)
        } else if (this._prelisten_track != undefined) {
            this.prelisten.play(this._prelisten_track,  (s != undefined) ? (s) : s)
        } else {

        }
    }

    stopPrelisten() {
        this.prelisten.stop()
    }

    togglePrelistenPause() {
        this.prelisten.togglePause()
    }

    getPrelistenState() {
        return this.prelisten.state
    }

    getPrelistenTrack() {
        return this._prelisten_track
    }

    prelistenSkip(s) {
        this.prelisten.skip(s)
    }

    prelistenLast10Seconds(track) {
        this.prelistenTrack(track, -10000)
    }

    prelistenLast30Seconds(track) {
        this.prelistenTrack(track, -30000)
    }

    reorderQueue(new_order, internal) {
        return this.library.queue.reorder(new_order, internal)
    }

    appendToQueue(element) {
        return this.library.queue.append(element)
    }

    removeFromQueue(element) {
        return this.library.queue.remove(element)
    }

    async getSessionById(sessionId) {
        let session_object = await this.library.sessions.getObjectById(sessionId)
        return {
            element: session_object,
            model: (new TrackSetModel(this.library, this.library.sessions, sessionId))
        }
    }

    async getPlaylistById(playlistId) {
        let playlist_object = await this.library.playlists.getObjectById(sessionId)
        return {
            element: playlist_object,
            model: (new TrackSetModel(this.library, this.library.sessions, sessionId))
        }
    }
}

module.exports = {
    PymusicAppController: PymusicAppController
}