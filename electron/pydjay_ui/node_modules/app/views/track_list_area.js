const { DetailedTrackListView } = require("app/components/detailed_track_list")
const { DOMElement } = require("ui/dom/domelement")
const { TrackSetModel } = require("musicdb/track_set.js")
const { ContextMenu } = require("./context_menu")
const { BoxLayout } = require("ui/layout/box")
const { TagPicker } = require("ui/popup/tagpicker")
const { TagFilterPicker } = require("ui/popup/tag_filter_picker")
const { ListInfoHeader } = require("app/components/list_header")


class MainTrackListContextMenu extends ContextMenu {
    constructor(track, library) {
        super(track, library)
    }
}
class TrackListAreaController extends BoxLayout {
    constructor(library) { 
        super('vertical')
        this.setStyle({
            position: "relative",
            width: "100%",
            height: "100%"
        })

        this.element = document.getElementById("main-list");
        this._library = library


        let listScroller = new DOMElement('div')
        listScroller.domElement.classList.add("main-track-list-area")
        listScroller.domElement.classList.add("queue-list")
        let listTableArea = new DOMElement('table')
        listTableArea.domElement.classList.add("main-track-list-table")
        listTableArea.setStyle({
            width: "100%"
        })
        let listTableBody = new DOMElement('tbody')
        listScroller.domElement.classList.add("list-group")
        listTableBody.setStyle({
            width: "100%"
        })
        listScroller.appendChild(listTableArea)
        listTableArea.appendChild(listTableBody)

        let listHeader =  new DOMElement('table')
        let listHeaderBody =  new DOMElement('thead')
        listHeaderBody.setStyle({
            width: "100%"
        })
        listHeader.appendChild(listHeaderBody)

        let listArea = new BoxLayout('vertical')
        listArea.append(listHeader, false, true, 25)
        listArea.append(listScroller, true, true)

        this._listview = new DetailedTrackListView(listTableArea, listTableBody, listScroller, listHeader)

        this.filterUnplayed = false
        this.filterTags = []

        this.infoHeader = new ListInfoHeader(library, true)
        this.infoHeader.setStyle({
            width: "100%",
            height: "100%",
            position: 'relative'
        })

        this.infoHeader.on('filter-changed', (filter) => {
            this.textFilter = filter
            this._listview.filterList(filter)
        })
        this.infoHeader.on('tag-filter-changed', (tags) => {
            this.tagFilterPicker = undefined
            this.filterUnplayed = tags.filterUnplayed
            this.filterTags = tags.filterTags
            this._listview.filterUnplayed = tags.filterUnplayed
            this.dispatch("tag-filter-changed", tags)
            if (Object.keys(tags.filterTags).length > 0) {
                this._listview.filterTags = tags.filterTags
            } else {
                this._listview.filterTags = undefined
            }
            this._listview.filterList(this.textFilter || "")    
        })

        this.append(this.infoHeader, false, true, 50)
        this.append(listArea, true, true)

        this.forward_content_changed = async (q) => {
            await this.updateContents()
        }

        this._library.tracks.on("object-updated", (x) => {
            this._listview.updateElement(x)
        })

        this.dimmModelContents = async () => {
            if (this.dimmingModel) {
                this._listview.setDimmedRows(await this.dimmingModel.getTrackIds())
            }
        }

        this._library.queue.on("content-changed", async () => {
            !(this.dimmingModel) && this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
        })
        this._library.current_session.on("content-changed", async () => {
            !(this.dimmingModel) && this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())    
        })
        this._library.unavailable_tracks.on("content-changed", async () => {
            !(this.dimmingModel) && this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())    
        })
        

        this._listview.on("row-click", () => {
            focusWindow(this)
        })

        this._listview.on("context-menu", async (trackId) => {
            let tracks = []
            for(let j=0; j<trackId.length; j++) {
                tracks.push(await this._library.tracks.getElementById(trackId[j]))
            }
            let _context_menu = new MainTrackListContextMenu(tracks, this._library)
            _context_menu.popup()
        })

        this._listview.on("row-double-click", async (trackId) => {
            let track = await this._library.tracks.getElementById(trackId)
            AppController.prelistenTrack(track)
        })

        this.tagPicker = undefined
        this._listview.on("row-tag-clicked", async (trackId, element) => {
            if (!this.tagPicker) {
                let track = await this._library.tracks.getElementById(trackId)
                let tags = await this._library.tags.d.find({_id: {$in: track.metadata.tags}})
                this.tagPicker = new TagPicker(document.getElementsByTagName("body")[0], {
                    tags: tags,
                    tagList: Object.values(await this._library.tags.getAllObjects()),
                    cancel: () => {
                        this.tagPicker = undefined
                    },
                    updateTags: async (tags) => {
                        await this._library.tracks.setTags(track, tags)
                    }                    
                })
                this.tagPicker.open(element)    
            } else {
                this.tagPicker.close()
                this.tagPicker = undefined
            }
        })

        this._listview.on("row-rating-clicked", async (trackId, value) => {
            let T = await this._library.tracks.getElementById(trackId)
            await this._library.tracks.setTrackMetadata(T, {"stats.rating": value})
        })

        this._listview.on("row-loved-clicked", async (trackId) => {
            let T = await this._library.tracks.getElementById(trackId)
            await this._library.tracks.setTrackMetadata(T, {"stats.loved": !(T.stats.loved)})
        })

        this._listview.on("row-values-edited", async (trackId, values) => {
            let T = await this._library.tracks.getElementById(trackId)
            await this._library.tracks.setTrackMetadata(T, {
                "metadata.title": (values.title == "") ? null : values.title,
                "metadata.artist": (values.artist == "") ? null : values.artist,
                "metadata.album": (values.album == "") ? null : values.album,
                "metadata.genre": (values.genre == "") ? null : values.genre,
                "track.bpm": (values.bpm == "") ? null : parseInt(values.bpm),
            })
        })

        this.element.appendChild(this.domElement)
    }

    async setDimmingModel(model) {
        if (this.dimmingModel) {
            this.dimmingModel.un("content-changed", this.dimmModelContents)
        }
        this.dimmingModel = model
        if (this.dimmingModel) {
            this.dimmingModel.on("content-changed", this.dimmModelContents)
            this._listview.setDimmedRows(await this.dimmingModel.getTrackIds())
        } else {
            this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
        }

    }

    async updateHeader() {
        let numTracks = await this.model.length()
        let duration = await this.model.duration()
        this.infoHeader.setMetadata({
            name : this.name,
            numTracks : numTracks,
            duration: duration,
        })
    }

    async updateContents() {
        let elements = await this.model.getTracks()
        this._listview.setList(elements)
        await this.updateHeader()
    }

    async displayModel(name, model, ignoreUnavailable, enforceModelOrder) {
        if (this.model != undefined) {
            this.model.un("content-changed", this.forward_content_changed) 
        }
        this.name = `${name}`
        if (model) {
            this.model = model
            this.model.on("content-changed", this.forward_content_changed) 
            this.updateContents()    
        } else {
            this._listview.setList([])
        }
        this._listview.ignore_unavailable = ignoreUnavailable
        this._listview.model_order = enforceModelOrder

        if (this.dimmingModel) {
            this._listview.setDimmedRows(await this.dimmingModel.getTrackIds())
        } else {
            this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
        }

    }

    async display_all_songs() {
        await this.displayModel("All Songs", this._library.tracks, false, false)
    }
    
    async display_current_session() {
        await this.displayModel("Current Session", this._library.current_session, true, true)
    }
    
    async display_suggestions() {
        await this.displayModel("Suggested tracks", this._library.suggested, false, false)
    }
    
    async display_short_list() {
        await this.displayModel("Short list", this._library.shortlisted_tracks, false, false)
    }
    
    async display_unavailable() {
        await this.displayModel("Unavailable tracks", this._library.unavailable_tracks, true, false)
    }
    
    async display_played_tracks() {
        await this.displayModel("Played songs", this._library.played_tracks, false, false)
    }
    
    async display_never_played_tracks() {
        await this.displayModel("Never Played songs", this._library.never_played_tracks, false, false)
    }
    
    async display_session(id) {
        let pl = await this._library.sessions.getObjectById(id)
        let model = new TrackSetModel(this._library, this._library.sessions, id)
        await this.displayModel(pl.event, model, false, true)
    }
    
    async display_playlist(id) {
        let pl = await this._library.playlists.getObjectById(id)
        let model = new TrackSetModel(this._library, this._library.playlists, id)
        await this.displayModel(pl.name, model, false, false)
    }

    async handle_double_click(e) {
        let x = e.target.closest("tr")
        let track_id = x.attributes["data-track-id"].value
        let track_element = await this.controller.getElementById(track_id)
        AppController.prelistenTrack.play(track_element)
    }

    handle_click(e) {
        focusWindow(this)
    }

    focus() {
        this.element.classList.add("focus")
    }

    blur() {
        this._listview.cancelEdit()
        this.element.classList.remove("focus")
    }

    begin_edit() {
        this._listview.beginEdit()
    }

    async selected_element() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            return await this._library.tracks.getElementById(selection[0])
        }
    }

    delete_selection() {

    }

    move_down() {
        this._listview.moveDown()
    }

    move_up() {
        this._listview.moveUp()
    }

    page_up() {
        let y = this.scroller.getBoundingClientRect()
        scroller.scrollTop -= y.height
    }

    page_down() {
        let y = this.scroller.getBoundingClientRect()
        scroller.scrollTop += y.height
    }

    move_last() {
        let e = this.view_list_id_order[this.view_list_id_order.length-1]
        this.ensure_row_visible(e)
        this.controller.select_element(e)
    }

    move_first() {
        let e = this.view_list_id_order[0]
        this.ensure_row_visible(e)
        this.controller.select_element(e)
    }

    async set_selected_rating(rating) {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.tracks.setTrackMetadata(T, {"stats.rating": rating})
        }
    }

    async toggle_selected_loved() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.tracks.setTrackMetadata(T, {"stats.loved": !(T.stats.loved)})
        }
    }

    async add_selection_to_queue() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await Q.add_element(T)
        }
    }

    async add_selection_to_shortlist() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.shortlisted_tracks.append(T)
        }
    }

    async add_selection_to_unavailable() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.unavailable_tracks.append(T)
        }
    }

    async remove_selection_from_unavailable() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.unavailable_tracks.remove(T)
        }
    }
}


module.exports = {
    TrackListAreaController: TrackListAreaController
}

// `
// What I mean by a 'fake problem' is quite simple. It is a problem that doesn't really exist, or isn't really a problem.

// Quite a few of the problems and issues that were discussed in this group are fake to some degree, though I do remember some a few years ago that were rooted in genuine issues.



// Racial diversity in contra dance isn't a problem. It isn't something anyone *needs*, but rather something some people *want*, because diversity and representation are the fashionable ussie du jour.

// Contra dance isn't diverse. Period. Not because the majority of dancers are white; 
// Look around a typical dance, and you will see that the vast majority of the dancers

// The problem isn't that the majority of contra dancers are white, but that
// they are a specific kind of white people.  Caucasians are not a monolithic group of people.


// `