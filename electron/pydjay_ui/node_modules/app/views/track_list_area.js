const { DetailedTrackListView } = require("./detailed_track_list")
const { EventDispatcher } = require("notify/event_dispatcher")
const { TrackSetModel } = require("musicdb/track_set.js")
const { ContextMenu } = require("./context_menu")
const { TagPicker } = require("ui/popup/tagpicker")
const { TagFilterPicker } = require("ui/popup/tag_filter_picker")

class MainTrackListContextMenu extends ContextMenu {
    constructor(track, library) {
        super(track, library)
    }
}
class TrackListAreaController extends EventDispatcher {
    constructor(library) { 
        super()
        this.element = document.getElementById("main-list");
        this._library = library
        this._listview = new DetailedTrackListView()

        this.filterUnplayed = false
        this.filterTags = []

        this.nameDOM = document.getElementById("main-track-list-name");
        this.numTracksDOM = document.getElementById("main-track-list-number-of-tracks");
        this.durationDOM = document.getElementById( "main-track-list-duration");
        this.filter_dom = document.getElementById("filter-track-list");
        this.tag_filter_dom = document.getElementById("choose-tag-filters");

        this.filter_dom.addEventListener("keyup", (e) => {
            if ((e.key == "Escape") || (e.key == "Enter")) {
                this.filter_dom.blur()
            }
        });
        this.tagFilterPicker = undefined
        this.tag_filter_dom.addEventListener("click", async () => {
            let tags = Object.values(await this._library.tags.getAllObjects()).map((x) => {
                return {
                    id: x._id,
                    name: x.name,
                    checked: (this.filterTags[x._id] != undefined) 
                }
            })
            if (!this.tagFilterPicker) {
                this.tagFilterPicker = new TagFilterPicker(document.getElementsByTagName("body")[0], {
                    filterUnplayed: this.filterUnplayed,
                    tags: tags, 
                    cancel: () => {
                        this.tagFilterPicker = undefined
                    },
                    updateFilter: async (tags) => {
                        this.tagFilterPicker = undefined
                        this.filterUnplayed = tags.filterUnplayed
                        this.filterTags = tags.filterTags
                        this._listview.filterUnplayed = tags.filterUnplayed
    
                        if (Object.keys(tags.filterTags).length > 0) {
                            this._listview.filterTags = tags.filterTags
                        } else {
                            this._listview.filterTags = undefined
                        }
                        this._listview.filterList(this.filter_dom.value)
                    }                    
                })
                this.tagFilterPicker.open(this.tag_filter_dom)    
            } else {
                this.tagFilterPicker.close()
                this.tagFilterPicker = undefined
            }
        })
        
        this.filter_dom.oninput = (e) => {
            this._listview.filterList(this.filter_dom.value)
        }

        this.forward_content_changed = async (q) => {
            await this.updateContents()
        }

        this._library.tracks.on("object-updated", (x) => {
            this._listview.updateElement(x)
        })

        this._library.queue.on("content-changed", async () => {
            this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
        })
        this._library.current_session.on("content-changed", async () => {
            this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())    
        })
        this._library.unavailable_tracks.on("content-changed", async () => {
            this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())    
        })
        

        this._listview.on("row-click", () => {
            focusWindow(this)
        })

        this._listview.on("context-menu", async (trackId) => {
            let tracks = []
            for(let j=0; j<trackId.length; j++) {
                tracks.push(await this._library.tracks.getElementById(trackId[j]))
            }
            // console.lsog(tracks)
            let _context_menu = new MainTrackListContextMenu(tracks,
                // await this._library.tracks.getElementById(trackId),
                this._library)
            _context_menu.popup()
        })

        this._listview.on("row-double-click", async (trackId) => {
            let track = await this._library.tracks.getElementById(trackId)
            AppController.prelistenTrack(track)
        })

        this.tagPicker = undefined
        this._listview.on("row-tag-clicked", async (trackId, element) => {
            if (!this.tagPicker) {
                let track = await this._library.tracks.getElementById(trackId)
                let tags = await this._library.tags.d.find({_id: {$in: track.metadata.tags}})
                this.tagPicker = new TagPicker(document.getElementsByTagName("body")[0], {
                    tags: tags,
                    tagList: Object.values(await this._library.tags.getAllObjects()),
                    cancel: () => {
                        this.tagPicker = undefined
                    },
                    updateTags: async (tags) => {
                        await this._library.tracks.setTags(track, tags)
                    }                    
                })
                this.tagPicker.open(element)    
            } else {
                this.tagPicker.close()
                this.tagPicker = undefined
            }
        })

        this._listview.on("row-rating-clicked", async (trackId, value) => {
            let T = await this._library.tracks.getElementById(trackId)
            await this._library.tracks.setTrackMetadata(T, {"stats.rating": value})
        })

        this._listview.on("row-loved-clicked", async (trackId) => {
            let T = await this._library.tracks.getElementById(trackId)
            await this._library.tracks.setTrackMetadata(T, {"stats.loved": !(T.stats.loved)})
        })

        this._listview.on("row-values-edited", async (trackId, values) => {
            let T = await this._library.tracks.getElementById(trackId)
            await this._library.tracks.setTrackMetadata(T, {
                "metadata.title": (values.title == "") ? null : values.title,
                "metadata.artist": (values.artist == "") ? null : values.artist,
                "metadata.album": (values.album == "") ? null : values.album,
                "metadata.genre": (values.genre == "") ? null : values.genre,
                "track.bpm": (values.bpm == "") ? null : parseInt(values.bpm),
            })
        })
    }

    async updateHeader() {
        let numTracks = await this.model.length()
        let duration = await this.model.duration()
        this.numTracksDOM.innerHTML = `${numTracks} tracks`
        this.durationDOM.innerHTML = `${format_seconds_long(duration / 1000)}`
    }


    async updateContents() {
        let elements = await this.model.getTracks()
        this._listview.setList(elements)
        await this.updateHeader()
    }

    async displayModel(name, model) {
        if (this.model != undefined) {
            this.model.un("content-changed", this.forward_content_changed) 
        }
        this.nameDOM.innerHTML = `${name}`
        if (model) {
            this.model = model
            this.model.on("content-changed", this.forward_content_changed) 
            this.updateContents()    
        } else {
            this._listview.setList([])
        }
    }

    async display_all_songs() {
        this._listview.ignore_unavailable = false
        this._listview.model_order = false
        await this.displayModel("All Songs", this._library.tracks)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_current_session() {
        this._listview.ignore_unavailable = true
        this._listview.model_order = true
        await this.displayModel("Current Session", this._library.current_session)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_suggestions() {
        this._listview.ignore_unavailable = false
        this._listview.model_order = false
        await this.displayModel("Suggested tracks", this._library.suggested)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_short_list() {
        this._listview.ignore_unavailable = false
        this._listview.model_order = false
        await this.displayModel("Short list", this._library.shortlisted_tracks)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_unavailable() {
        this._listview.ignore_unavailable = true
        this._listview.model_order = false
        await this.displayModel("Unavailable tracks", this._library.unavailable_tracks)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_played_tracks() {
        this._listview.ignore_unavailable = false
        this._listview.model_order = false
        await this.displayModel("Played songs", this._library.played_tracks)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_never_played_tracks() {
        this._listview.ignore_unavailable = false
        this._listview.model_order = false
        await this.displayModel("Never Played songs", this._library.never_played_tracks)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_session(id) {
        let pl = await this._library.sessions.getObjectById(id)
        let model = new TrackSetModel(this._library, this._library.sessions, id)
        this._listview.ignore_unavailable = false
        this._listview.model_order = true
        await this.displayModel(pl.event, model)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }
    
    async display_playlist(id) {
        let pl = await this._library.playlists.getObjectById(id)
        let model = new TrackSetModel(this._library, this._library.playlists, id)
        this._listview.ignore_unavailable = false
        this._listview.model_order = false
        await this.displayModel(pl.name, model)
        this._listview.setDimmedRows(await this._library.unavailable.getTrackIds())
    }

    async handle_double_click(e) {
        let x = e.target.closest("tr")
        let track_id = x.attributes["data-track-id"].value
        let track_element = await this.controller.getElementById(track_id)
        AppController.prelistenTrack.play(track_element)
    }

    handle_click(e) {
        focusWindow(this)
    }

    focus() {
        this.element.classList.add("focus")
    }

    blur() {
        this._listview.cancelEdit()
        this.element.classList.remove("focus")
    }

    begin_edit() {
        this._listview.beginEdit()
    }

    async selected_element() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            return await this._library.tracks.getElementById(selection[0])
        }
    }

    delete_selection() {

    }

    move_down() {
        this._listview.moveDown()
    }

    move_up() {
        this._listview.moveUp()
    }

    page_up() {
        let y = this.scroller.getBoundingClientRect()
        scroller.scrollTop -= y.height
    }

    page_down() {
        let y = this.scroller.getBoundingClientRect()
        scroller.scrollTop += y.height
    }

    move_last() {
        let e = this.view_list_id_order[this.view_list_id_order.length-1]
        this.ensure_row_visible(e)
        this.controller.select_element(e)
    }

    move_first() {
        let e = this.view_list_id_order[0]
        this.ensure_row_visible(e)
        this.controller.select_element(e)
    }

    async set_selected_rating(rating) {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.tracks.setTrackMetadata(T, {"stats.rating": rating})
        }
    }

    async toggle_selected_loved() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.tracks.setTrackMetadata(T, {"stats.loved": !(T.stats.loved)})
        }
    }

    async add_selection_to_queue() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await Q.add_element(T)
        }
    }

    async add_selection_to_shortlist() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.shortlisted_tracks.append(T)
        }
    }

    async add_selection_to_unavailable() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.unavailable_tracks.append(T)
        }
    }

    async remove_selection_from_unavailable() {
        let selection = this._listview.getSelection()
        if (selection.length == 1) {
            let T = await this._library.tracks.getElementById(selection[0])
            await this._library.unavailable_tracks.remove(T)
        }
    }
}


module.exports = {
    TrackListAreaController: TrackListAreaController
}

// `
// What I mean by a 'fake problem' is quite simple. It is a problem that doesn't really exist, or isn't really a problem.

// Quite a few of the problems and issues that were discussed in this group are fake to some degree, though I do remember some a few years ago that were rooted in genuine issues.



// Racial diversity in contra dance isn't a problem. It isn't something anyone *needs*, but rather something some people *want*, because diversity and representation are the fashionable ussie du jour.

// Contra dance isn't diverse. Period. Not because the majority of dancers are white; 
// Look around a typical dance, and you will see that the vast majority of the dancers

// The problem isn't that the majority of contra dancers are white, but that
// they are a specific kind of white people.  Caucasians are not a monolithic group of people.


// `