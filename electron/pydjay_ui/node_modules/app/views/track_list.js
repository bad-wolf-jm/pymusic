const { ClusteredListView } = require('ui/listview/cluster')
const moment = require('moment');

class CellRenderer {
    constructor(config) {
        this._config = config
        this._baseStyle = ['white-space: nowrap', 'overflow: hidden', 'text-overflow: ellipsis']
    }

    _getValue(key, obj, def) {
        if (this._config[key]) {
            return this._config[key](obj)
        }
    }

    _decamelize(str, separator){
        separator = typeof separator === 'undefined' ? '-' : separator;
    
        return str
            .replace(/([a-z\d])([A-Z])/g, '$1' + separator + '$2')
            .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + separator + '$2')
            .toLowerCase();
    }

    _renderStyle(obj) {
        let styleElements = ["color", "backgroundColor", "textAlign", "maxWidth", "width"]
        let style = []
        styleElements.forEach((s) => {
            let styleElement;
            if (this._config[s] && typeof this._config[s] == "function") {
                styleElement = `${this._decamelize(s)}: ${this._config[s](obj)}`
            } else if (this._config[s]) {
                styleElement = `${this._decamelize(s)}: ${this._config[s]}`
            } else if (obj[s]) {
                styleElement = `${this._decamelize(s)}: ${obj[s]}`
            }
            styleElement && style.push(styleElement)
        })
        return `${this._baseStyle.join('; ')}; ${style.join("; ")}`
    }

    renderEditor(id, obj) {
        return `<input id="${id}" type="text" class="new-playlist" value="">`
    }
}

class TextRenderer extends CellRenderer {
    constructor(config) {
        super(config)
    }

    render(rowId, colId, obj) {
        let style = this._renderStyle(obj)
        let text = this._getValue("text", obj)
        let id = this._getValue("id", obj)
        return `<td ${id ? `id='${id(rowId, colId)}'` : ""} style="${style}">${text}</td>`
    }

    renderEditor(id, obj) {
        let text = this._getValue("text", obj)
        text = text ? text : ""
        return `<input id="${id}" type="text" class="new-playlist" value="${text}">`
    }

}



class NumberRenderer extends CellRenderer {
    constructor(config) {
        super(config)
    }

    render(rowId, colId, obj) {
        let style = this._renderStyle(obj)
        let text = this._getValue("text", obj)
        let id = this._getValue("id", obj)
        text = text ? text : ""
        return `<td ${id ? `id='${id(rowId, colId)}'` : ""} style="${style}">${text}</td>`
    }

    renderEditor(id, obj) {
        let text = this._getValue("text", obj)
        text = text ? text : ""
        return `<input id="${id}" type="text" class="new-playlist" value="${text}">`
    }
}


class DateRenderer extends CellRenderer {
    constructor(config) {
        super(config)
    }

    render(rowId, colId, obj) {
        let style = this._renderStyle(obj)
        let date = this._getValue("date", obj)
        let text;
        if (date) {
            text = moment(date).format(this._config.dateFormat ? this._config.dateFormat : 'MM-DD-YYYY')
        } else {
            text = ""
        }
        let id = this._getValue("id", obj)
        return `<td ${id ? `id='${id(rowId, colId)}'` : ""} style="${style}">${text}</td>`
    }
}




class TrackListView extends ClusteredListView {
    constructor(dom_ids, queue_controller, shortlist_controller, unavailable_controller) {
        super(document.getElementById("main-track-list-body"), document.getElementById("main-track-list-scroller"))
        this.setupColumnRenderers()
        this.dom_id = dom_ids.list
        this.prevWidth = [];
        this._objectid_to_row_id = {}
    }

    compare_tracks(a, b) {
        if (!a.metadata.title) { return -1 }
        if (!b.metadata.title) { return 1 }
        let x = a.metadata.title.toLowerCase();
        let y = b.metadata.title.toLowerCase();
        if (x < y) { return -1; }
        if (x > y) { return 1; }
        return 0;        
    }    

    convert_track(track_element) {
        let { metadata, stats, track } = track_element
        return {
            id: track_element._id,
            color: metadata.color,
            title: metadata.title,
            artist: metadata.artist,
            album: metadata.album,
            genre: metadata.genre,
            last_played: stats.last_played, 
            play_count: stats.play_count,
            duration: track.stream_end - track.stream_start,
            bpm: track.bpm,
            loved: stats.loved,
            rating: stats.rating
        }
    }

    clusterChanged(rows) {

    }

    setupColumnRenderers() {
        this.addColumnRenderer({_config: {}, render: (row, col, track) => {
            return `<td style="width:25px; text-align:center">
                <input id='track-color-value-${track.id}' type="hidden" value="" class="main-list-color-value" data-track-id=${track.id}/>
                <button id='${this._viewId}-color-${track.id}' class="main-list color-chooser show-color-picker" style="background-color:${track.color}" data-track-id=${track.id}></button>
            </td>`}})

        this.addColumnRenderer({_config: {}, render: (row, col, track) => {
            return `<td id='track-loved-${track.id}' style="width:25px; padding:5px 3px 5px 3px; text-align:center; font-size:8pt; color:${track.color}">
                ${this._get_loved(track)}
            </td>`}})

        this.addColumnRenderer(new TextRenderer({
            maxWidth: "110px",
            editTag: "title",
            color: (obj) => {return obj.color},
            text: (obj) => {return obj.title}
        }))
            
        this.addColumnRenderer(new TextRenderer({
            maxWidth: "90px",
            editTag: "artist",
            color: (obj) => {return obj.color},
            text: (obj) => {return obj.artist}
        }))

        this.addColumnRenderer(new TextRenderer({
            maxWidth: "90px",
            editTag: "album",
            color: (obj) => {return obj.color},
            text: (obj) => {return obj.album}
        }))

        this.addColumnRenderer(new TextRenderer({
            maxWidth: "40px",
            editTag: 'genre',
            color: (obj) => {return obj.color},
            text: (obj) => {return obj.genre}
        }))

        this.addColumnRenderer(new NumberRenderer({
            width: "30px",
            textAlign: 'right',
            color: (obj) => {return obj.color},
            text: (obj) => {return obj.play_count}
        }))

        this.addColumnRenderer(new DateRenderer({
            width: "75px",
            textAlign: "right",
            dateFormat: "MM-DD-YYYY",
            color: (obj) => {return obj.color},
            date: (obj) => {return obj.last_played}
        }))
            
        this.addColumnRenderer({_config: {}, render: (row, col, track) => {
            return `<td id='track-rating-${track.id}' style="width:25px; color:${track.color}">
                ${this._get_rating(track)}
            </td>`}})

        this.addColumnRenderer(new NumberRenderer({
            width: "30px",
            textAlign: 'right',
            editTag: "bpm",
            color: (obj) => {return obj.color},
            text: (obj) => {return obj.bpm}
        }))

        this.addColumnRenderer(new DateRenderer({
            width: "75px",
            textAlign: "right",
            dateFormat: "m:ss",
            color: (obj) => {return obj.color},
            date: (obj) => {return obj.duration}
        }))
    }

    fitHeaderColumns() {
        let $headers = $("#track-list-elements-header")
        let $firstRow = $("#main-track-list-table").find('tr:not(.clusterize-extra-row):first');
        let columnsWidth = [];
        $firstRow.children().each(function () {
            columnsWidth.push($(this).width());
        });
        if (columnsWidth.toString() == this.prevWidth.toString()) return;
        $headers.find('tr').children().each(function(i) {
            $(this).width(columnsWidth[i]);
        });
        this.prevWidth = columnsWidth;
    }

    async set_list(name, list_elements) {
        if (list_elements == undefined) {
            list_elements = []
        }

        if (!this.model_order) {
            list_elements.sort(this.compare_tracks)
        }

        let rowIds = this.setRows(list_elements.map((e) => {
            return this.convert_track(e)
        }))

        this._objectid_to_row_id = {}

        Object.keys(rowIds).forEach((id) => {
            this._objectid_to_row_id[rowIds[id].id] = id
        })
    }

    setDimmedRows(idList) {
        let rowIdList = idList.map((x) => {
            return this._objectid_to_row_id[x]
        }).filter((x) => {
            return x
        })
        super.setDimmedRows(rowIdList)
    }

    set_controller(controller) {
        this.controller = controller
        this.controller.addView(this)
        this.controller.on("content-changed", this.set_list.bind(this))
        this.controller.on("element-updated", this.update_element.bind(this))
        this.controller.on("metadata-changed", this.update_element.bind(this))
    }

    _get_loved(track_object) {
        return `<i id='${this._viewId}-loved-${track_object.id}' title='${track_object.id}' class='fa ${(track_object.loved ? "fa-heart" : "fa-heart-o")}'></i>`
    }

    _get_rating(track_object) {
        let html = "";
        for (let j=1; j<6; j++) {
            html += `<i id='${this._viewId}-rating-${track_object.id}-${j}' class='fa ${( j <= track_object.rating ? "fa-star" : "fa-star-o")}' style='font-size:8pt; margin-left:3px'></i>`;
        }
        return html
    }

    handleContextMenu(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        this.dispatch("context-menu", trackObject.id)
    }

    handleDragStart(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        e.dataTransfer.setData("text/plain", trackObject.id)
    }

    handleDoubleClick(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        this.dispatch("row-double-click", trackObject.id)
        this.begin_edit()
    }

    dispatch(signal, ...x) {
        console.log(signal, x)
        super.dispatch(signal, ...x)
    }

    handleClick(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        let eventElementId = e.target.id

        let rating_regex = new RegExp(`${this._viewId}-rating-([a-zA-Z0-9]+)-(\\d+)`)
        let matches = rating_regex.exec(eventElementId)
        if (matches != undefined) {
            let rating_value = parseInt(matches[2])
            this.dispatch("row-rating-clicked", trackObject.id, rating_value)
            e.preventDefault()
            return;
        }

        let loved_regex = new RegExp(`${this._viewId}-loved-([a-zA-Z0-9]+)`)
        matches = loved_regex.exec(eventElementId)
        if (matches != undefined) {
            this.dispatch("row-loved-clicked", trackObject.id)
            e.preventDefault()
            return;
        }

        let color_regex = new RegExp(`${this._viewId}-color-([a-zA-Z0-9]+)`)
        matches = color_regex.exec(eventElementId)
        if (matches != undefined) {
            let track_id = matches[1]
            this.dispatch("row-color-clicked", e, trackObject.id)
            e.preventDefault()
            return;
        }

        this.dispatch("row-click", trackObject.id)
        this.selectRow(tableRow.id)
 
    }

    delete_selection() {

    }

    _keypress (e) {
        if (e.key == "Escape") {
            this.cancel_edit()
        } else if (e.key == "Enter") {
            this.save_edit()
        } else if (e.key == "Alt") {
            if (this.edit_bpm != undefined) {
                let t = this.edit_bpm.tap()
                let bpm = Math.round(t.avg)
                if (!isNaN(bpm)) {
                    this.editValues[editTag].value = bpm
                    // document.getElementById(`main-track-list-edit-bpm-${this.edit_row._id}`).value = bpm
                }
            }
        } else {

        }
    }

    begin_edit() {
        if (this._selection.length() == 1) {
            this.edit_mode = true
            let row_id_to_edit = this._selection.getElementIds()[0]
            let rowToEdit = this._row_elements.getElementById(row_id_to_edit)
            let objectToEdit = this._elements.getElementById(row_id_to_edit)
            this.editValues = {}
            this.oldRowValues = {}
            this.editRowCells = {}
            for (let i = 0; i<this._column_renderers.length; i++) {
                if (this._column_renderers[i]._config.editTag) {
                    let editTag = this._column_renderers[i]._config.editTag
                    let newId = this._id()
                    let editor = this._column_renderers[i].renderEditor(newId, objectToEdit)
                    this.editValues[editTag] = newId
                    this.oldRowValues[editTag] = rowToEdit.children[i].innerHTML
                    this.editRowCells[editTag] = rowToEdit.children[i]
                    rowToEdit.children[i].innerHTML = editor
                    this.editValues[editTag] = rowToEdit.children[i].children[0]
                    rowToEdit.children[i].children[0].addEventListener("keyup", (e) => {
                        this._keypress(e)
                    })
                }
            }
        }
    }

    save_edit() {
        if (this.edit_mode) {
            let values = {}
            Object.keys(this.editValues).forEach((k) => {
                values[k] = this.editValues[k].value
            })
            this.cancel_edit()
            this.dispatch("row-valued-edited", values)
        }
    }

    cancel_edit() {
        if (this.edit_mode) {
            Object.keys(this.editRowCells).forEach((k) => {
                this.editRowCells[k].innerHTML = this.oldRowValues[k]
            })
            this.edit_mode = false
        }
    }

    updateCell(id, new_value) {
        let cell = document.getElementById(id)
        if (cell) {
            cell.innerHTML = new_value
        } 
    }

    updateCellStyle(id, style, new_value) {
        let cell = document.getElementById(id)
        if (cell) {
            cell.style[style] = new_value
        } 
    }

    update_element(x) {
        let row = this.table_rows[x._id]
        x = this.convert_track(x)
        this.updateCell(`track-rating-${x.id}`, this._get_rating(x))
        this.updateCell(`track-loved-${x.id}`, this._get_loved(x))
        this.updateCell(`track-title-${x.id}`, x.title)
        this.updateCell(`track-artist-${x.id}`, x.artist)
        this.updateCell(`track-genre-${x.id}`, x.genre)
        this.updateCell(`track-bpm-${x.id}`, x.bpm)
        this.updateCell(`track-play-count-${x.id}`, x.play_count)
        this.updateCell(`track-last-played-${x.id}`, x.last_played)
        this.updateCell(`track-duration-${x.id}`, `${format_nanoseconds(x.duration)}`)
        this.updateCellStyle(`track-color-${x.id}`, 'backgroundColor', x.color)
        this.updateCellStyle(`track-row-${x.id}`, 'color', x.color)
    }

    getTrackTableElement(trackId) {
        return this.table_rows[trackId]
    }

    async filter_list (text) {
        this.list_cluster.update(await super.filter_list(text))
    };
}


module.exports = {
    TrackListView: TrackListView
}