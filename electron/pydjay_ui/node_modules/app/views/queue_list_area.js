

const { SimpleTrackListView } = require("app/components/simple_track_list")
const { ContextMenu } = require("./context_menu")
const { ListInfoHeader } = require("app/components/list_header")
const { BoxLayout } = require("ui/layout/box")
const { DOMElement } = require("ui/dom/domelement.js")
const { StackLayout } = require("ui/layout/stack")
const { Button } = require("ui/dom/button")

const { remote } = require('electron')
const { MenuItem } = remote


class QueueContextMenu extends ContextMenu {
    constructor(track, position, library, model) {
        super(track, library)
        this.model = model
        this.position = position
        this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Remove track', click: async () => {
            this.model.remove(track[0]) 
        }}))
    }
}


class ListPane extends BoxLayout {
    constructor(library) {
        super('vertical')

        let listScroller = new DOMElement('div')
        listScroller.domElement.classList.add("queue-list")
        let listTableArea = new DOMElement('table')
        listTableArea.setStyle({
            width: "100%"
        })
        let listTableBody = new DOMElement('tbody')
        listScroller.domElement.classList.add("list-group")
        listTableBody.setStyle({
            width: "100%"
        })
        listScroller.appendChild(listTableArea)
        listTableArea.appendChild(listTableBody)


        this.listArea = new SimpleTrackListView(listScroller.domElement, listTableBody.domElement)

        this._library = library

        this.infoHeader = new ListInfoHeader(library)
        this.infoHeader.setStyle({
            width: "100%",
            height: "100%",
            position: 'relative'
        })

        this.append(this.infoHeader, false, true, 50)
        this.append(listScroller, true, true)

        this.listArea.on("list-reordered", async (newOrder) => {
            this.listArea.clearDimmedRows("duplicate")
            await this.model.reorder(newOrder)
            await this.updateHeader()
            await this.updateDimmedRows()
        })

        this.listArea.on("context-menu", async (itemId, itemPosition) => {
            let contextMenu = new QueueContextMenu(                
                [await this._library.tracks.getElementById(itemId)],
                itemId,
                this._library, this.model)
            contextMenu.popup()
        })

        this.listArea.on("row-double-click", async (itemId) => {
            let track = await this._library.tracks.getElementById(itemId)
            AppController.prelistenTrack(track)
        })

        this.listArea.on("track-dropped", async (itemId) => {
            let track = await this._library.tracks.getElementById(itemId)
            if (track) {
                await this.model.append(track)
                await this.updateContents()  
            }
        })

        this.forward_content_changed = async (q) => {
            await this.updateContents()
        }
        
        this.forward_object_updated = async (q) => {

        }

        this._library.queue.on("content-changed", async () => {
            await this.updateDimmedRows() 
        })
        this._library.current_session.on("content-changed", async () => {
            await this.updateDimmedRows()
        })
        this._library.unavailable_tracks.on("content-changed", async () => {
            await this.updateDimmedRows()
        })
    }

    async updateHeader() {
        let numTracks = await this.model.length()
        let duration = await this.model.duration()
        this.infoHeader.setMetadata({
            name : this.name,
            numTracks : numTracks,
            duration: duration,
        })
    }


    async updateContents() {
        let elements = await this.model.getTracks()
        this.listArea.setList(elements)
        await this.updateHeader()
        await this.updateDimmedRows()
    }


    async updateDimmedRows() {
        if (this._dimUnavailableRows) {
            let _unavailableRows = await this._library.unavailableOrPlayed.getTrackIds()
            let unavailableRows = {}
            _unavailableRows.forEach((id) => {
                unavailableRows[id] = true
            })
            let duplicateQueueEntries = {}
            let unavailableQueueEntries = {}
            let trackEntries = await this.model.getOrderingIds()
            let position = 0
            trackEntries.forEach((id) => {
                if (duplicateQueueEntries[id]) {
                    duplicateQueueEntries[id].push(position)
                } else {
                    duplicateQueueEntries[id] = [position]
                }
                if (unavailableRows[id]) {
                    unavailableQueueEntries[id] = position
                }
                position++
            })
            let duplicates = []
            Object.keys(duplicateQueueEntries).forEach((o) => {
                if (duplicateQueueEntries[o].length > 1) {
                    let duplicatedIndices = duplicateQueueEntries[o].sort().slice(1)
                    duplicates.push(...duplicatedIndices)
                }
            })
            this.listArea.clearDimmedRows("duplicate")
            this.listArea.dimmRowList(Object.values(unavailableQueueEntries), "duplicate")
            this.listArea.dimmRowList(duplicates, "duplicate")
        }
    }

    async displayModel(name, model) {
        if (this.model != undefined) {
            this.model.un("content-changed", this.forward_content_changed) 
            this.model.un("object-updated", this.forward_object_updated)
        }
        this.name = `${name}`
        if (model) {
            this.model = model
            this.model.on("content-changed", this.forward_content_changed) 
            this.model.on("object-updated", this.forward_object_updated)
            this.updateContents()    
        } else {
            this.listArea.setList([])
        }
    }

    moveDown() {
        this.listArea.moveDown()
    }

    moveUp() {
        this.listArea.moveUp()
    }

    deleteSelection() {

    }

    addElement(e) {
        this.model.append(e)
    }
}


class QueueAreaController extends StackLayout {
    constructor(element, library) {
        super()
        this.library = library

        this.setStyle({
            width: "100%",
            height: "100%",
            position: "relative"
        })


        this.element = element //document.getElementById("queue-list")
        this.queue_view = new ListPane(library)
        this.queue_view._dimUnavailableRows = true
        this.playlist_editor = new ListPane(library) 

        this.addItem("queue", this.queue_view)
        this.addItem("playlist-edit", this.playlist_editor)

        //this.element.appendChild(this.domElement)

        this.displayed = undefined

        // this.element.addEventListener("click", () => {
        //     focusWindow(this)
        // })

        let closePLEditorButton = new Button()
        closePLEditorButton.setStyle({
            borderRadius: '5px',
            backgroundColor: 'rgb(40,40,40)',
            border: '1px solid grey'

        })
        closePLEditorButton.setText(`<i class="fa fa-close"></i>&nbsp;CLOSE`)
        closePLEditorButton.on("click", () => {
            this.hide_playlist_editor()
            this.playlist_editor.displayModel("")
            T.setDimmingModel(undefined)
        })
        this.playlist_editor.infoHeader.append(closePLEditorButton, false, true, 70)
    }


    show_playlist_editor() {
        this.displayItem("playlist-edit")
        this.displayed = this.playlist_editor
    }

    hide_playlist_editor() {
        this.displayItem("queue")
        this.displayed = this.queue_view
    }

    focus() {
        this.element.classList.add("focus")
    }

    blur() {
        this.element.classList.remove("focus")
    }

    delete_selection() {
        if (this.displayed != undefined) {
            this.displayed.deleteSelection()
        }
    }

    async selected_element() {
        if (this.displayed != undefined) {
            let selection = this.displayed.listArea.getSelection()
            if (selection.length == 1) {
                return await this.library.tracks.getElementById(selection[0])
            }
        }
    }


    move_down() {
        if (this.displayed != undefined) {
            this.displayed.moveDown()
        }
    }

    move_up() {
        if (this.displayed != undefined) {
            this.displayed.moveUp()
        }
    }

    add_element(e) {
        if (this.displayed != undefined) {
            this.displayed.addElement(e)
        }        
    }

    move_last() {

    }


    move_first() {

    }

    page_up() {
        if (this.displayed != undefined) {
            this.displayed.page_up()
        }
    }

    page_down() {
        if (this.displayed != undefined) {
            this.displayed.page_down()
        }
    }

    add_selection_to_queue() {

    }

    add_selection_to_shortlist() {

    }

    add_selection_to_unavailable() {

    }

    remove_selection_from_unavailable() {

    }

    move_selection_up() {
        if (this.displayed != undefined) {
            this.displayed.listArea.moveSelectionUp()
        }
    }

    move_selection_down() {
        if (this.displayed != undefined) {
            this.displayed.listArea.moveSelectionDown()
        }
    }

    move_selection_to_top() {
        if (this.displayed != undefined) {
            this.displayed.move_selection_to_top()
        }
    }

    set_selected_rating(rating) {
        if (this.displayed != undefined) {
            this.displayed.set_selected_rating(rating) 
        }
    }

    toggle_selected_loved() {

    }


}


module.exports = {
    QueueAreaController: QueueAreaController
}