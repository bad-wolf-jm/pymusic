const { remote } = require('electron')
const { Menu, MenuItem } = remote
const { TrackClipDialog } = require("../dialogs/track_clip_dialog")
const { AudioOutputDetector } = require('webaudio/detect')

class ContextMenu {
    constructor(track, library) {
        this.track = track
        this.library = library
        this.menu = new Menu();
        (this.track.length == 1) && this.menu.append(new MenuItem({label: 'Track info', click: () => {
            AppController.stopPrelisten()
            view.set_track(this.track[0])
            document.getElementById("track-edit-dialog").showModal()
        }}));
        (this.track.length == 1) && this.menu.append(new MenuItem({label: 'Clip track', click: async () => {
            AppController.stopPrelisten()
            let audio_setup = await this.library.getAudioSetup()
            let audio_outputs_devices = await (new AudioOutputDetector().detectAutioOutputs())
            let audio_outputs = {}
            audio_outputs_devices.forEach((o) => {
                audio_outputs[o.deviceId] = o.label
            })
        
            d = new TrackClipDialog(this.track[0], this.library)
            if (audio_outputs[audio_setup.prelisten]) {
                d.setOutputDeviceId(audio_setup.prelisten)
            } else {
                d.setOutputDeviceId("null")
            }        
            d.open()
        }}));
        (this.track.length == 1) && this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Shortlist', click: async () => {
            for (let i=0; i<this.track.length; i++) {
                await this.library.shortlisted_tracks.append(this.track[i])
            }
        }}))

        this.menu.append(new MenuItem({label: 'Marked as played', click: async () => {
            for (let i=0; i<this.track.length; i++) {
                await this.library.unavailable_tracks.append(this.track[i])
            }
        }}))

        this.menu.append(new MenuItem({label: 'Add to queue', click: async () => {
            for (let i=0; i<this.track.length; i++) {
                await this.library.queue.append(this.track[i])
            }
        }}));
        
        (this.track.length == 1) && this.menu.append(new MenuItem({type:  'separator'}));
        (this.track.length == 1) && this.menu.append(new MenuItem({label: 'Preview',
            submenu: [
                {label: 'Full track', click: () => {
                    AppController.prelistenTrack(this.track[0])
                }},
                {label: 'Last 30 seconds', click: () => {
                    AppController.prelistenLast30Seconds(this.track[0])
                }},
                {label: 'Last 10 seconds', click: () =>{
                    AppController.prelistenLast10Seconds(this.track[0])
                }}
            ]}));

        this._tagsSeparator = new MenuItem({id: "tagSeparator", type: 'separator'})
        this.menu.append(this._tagsSeparator)

        this._tagsMenu = new MenuItem({
            label: 'Tags',
            type: "submenu",
            submenu: new Menu()
        })
        this.menu.append(this._tagsMenu)
        

        this.menu.on("menu-will-show", (e) => {})
        this.menu.on("menu-will-close", (e) => {})
    }

    async popup() {
        let tags = Object.values(await this.library.tags.getAllObjects())

        tags.forEach((tag) => {
            this._tagsMenu.submenu.append(new MenuItem({
                label: tag.name,
                type: "checkbox",
                checked: this.track.map((x) => {
                    return x.metadata.tags.indexOf(tag._id) != -1}
                ).filter((x) => {return x}).length >= 1,
                click: (e) => {
                    this.track.forEach((track) => {
                        if ( e.checked ) {
                            this.library.tracks.appendTag(track, tag)
                        } else {
                            this.library.tracks.removeTag(track, tag)
                        }    
                    })
                }
            }))
        })

        this.menu.popup({window: remote.getCurrentWindow()})
    }

    close() {
        this.menu.closePopup()
    }
}

module.exports = {
    ContextMenu: ContextMenu
}