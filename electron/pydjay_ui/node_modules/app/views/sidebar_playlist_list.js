const { ClusteredListView } = require('ui/listview/cluster')
const { DOMElement } = require('ui/dom/domelement')
const { TrackSetModel } = require("musicdb/track_set.js")
const { SpaceRenderer, TextRenderer, NumberRenderer } = require('ui/listview/renderer')
const { remote } = require('electron')
const { Menu, MenuItem } = remote

class ContextMenu {
    constructor(playlist, model, library, display) {
        this.playlist = playlist
        this.model = model
        this.library = library
        this.display = display

        this.menu = new Menu()
        this.menu.append(new MenuItem({label: 'New playlist', click: async () => {
            this.display.beginAdd()
        }}))
        this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Edit...', click: async () => {
            let p = await this.model.getObjectById(this.playlist.id)
            let L = new TrackSetModel(MDB, MDB.playlists, this.playlist.id)
            Q.playlist_editor.displayModel(p.name, L)
            Q.show_playlist_editor()
            T.setDimmingModel(L)
        }}))
        this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Rename', click: () => {
            this.display.beginEdit(this.playlist.id)
        }}))
        this.menu.append(new MenuItem({label: 'Duplicate', click: async () => {
            await this.model.duplicatePlaylist(this.playlist.id)
        }}))
        this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Delete', click: async () => {
            let T = this.context_menu_element
            let playlist = await this.model.getObjectById(this.playlist.id)
            let dialog = new Question({
                title: "Delete playlist",
                question: `Delete <i><b>'${playlist.name}'</b></i>? This operation cannot be undone`,
                confirmText: "yes",
                dismissText: 'no',
                confirmAction: async () => {
                    await await this.model.deletePlaylist(this.playlist.id)
                    dialog.close()
                },
                dismissAction: () => {
                    dialog.close()
                },
            })
            dialog.open()    
        }}))
    }

    popup() {
        this.menu.popup({window: remote.getCurrentWindow()})
    }

    close() {
        this.menu.closePopup()
    }

    async create_playlist(name) {
        return await this.model.createPlaylist(name)
    }

    async rename_playlist(id, new_name) {
        return await this.model.renamePlaylist(id, new_name)
    }

    async checkNameAvailability(name, k) {
        return await this.model.checkNameAvailability(name)
    }
}

class PlaylistListView extends ClusteredListView {
    constructor(scroller, elements) {
        super(elements.domElement, scroller.domElement)
        this.setupColumnRenderers()
        this._objectid_to_row_id = {}
        this.forward_content_changed = async (q) => {
            await this.updateContents(q)
        }

        this.forward_object_changed = async (q) => {
            await this.updateElement(q)
        }


    }

    convert_playlist(playlist_element) {
        return {
            id: playlist_element._id,
            name: playlist_element.name,
            count: Object.keys(playlist_element.elements).length
        }
    }

    setupColumnRenderers() {
        this.addColumnRenderer(new SpaceRenderer({
            width: "10px",
            color: (obj) => {return null},
            text: (obj) => {return "&nbsp;"}
        }))

        this.addColumnRenderer(new TextRenderer({
            width: "15px",
            color: (obj) => {return null},
            text: (obj) => {return `<i class="fa fa-circle-o arrow-icon"></i>`}
        }))
            
        this.addColumnRenderer(new TextRenderer({
            width: "255px",
            editTag: "name",
            color: (obj) => {return null},
            text: (obj) => {return obj.name}
        }))

        this.addColumnRenderer(new NumberRenderer({
            width: "35px",
            textAlign: "right",
            color: (obj) => {return "rgb(128,128,128)"},
            text: (obj) => {return obj.count}
        }))

        this.addColumnRenderer(new TextRenderer({
            width: "25px",
            textAlign:"center",
            color: (obj) => {return null},
            text: (obj) => {return `<i class="fa fa-angle-right"></i>`}
        }))
    }


    async handleEditKeypress(e) {
        let new_name = this.editValues['name'].value
        if ((new_name == this.oldName) || (await this.model.checkNameAvailability(new_name))) {
            this.editValues['name'].style.color = null
        } else {
            this.editValues['name'].style.color = "#dd0000"
        }
    }

    async beginAdd() {
        this._addMode = true
        let newPlaylist = await this.model.createPlaylist()
        this._newPlaylistId = newPlaylist._id
        // console.log(this._objectid_to_row_id, this._newPlaylistId)
        this.beginEdit(newPlaylist._id) 
        //this._objectid_to_row_id[this._newPlaylistId])
    }

    beginEdit(id) {
        id = this._objectid_to_row_id[id]
        let rowId = super.beginEdit(id)

        this.editId = this._elements.getElementById(rowId).id
        this.oldName = this._elements.getElementById(rowId).name
    }

    async saveEdit() {
        let values = super.saveEdit()
        if (await this.model.checkNameAvailability(values.name)) {
            await this.model.renamePlaylist(this.editId, values.name)
        } else {
            this.editValues['name'].style.color = "#dd0000"
        }
    }

    async cancelEdit() {
        super.cancelEdit()
        if (this._newPlaylistId) {
            await this.model.deletePlaylist(this._newPlaylistId)
            this._newPlaylistId = undefined
            this._addMode = false
        }
    }

    handleContextMenu(e) {
        let tableRow = e.target.closest("tr")
        let playlistObject = this._elements.getElementById(tableRow.id)
        let menu = new ContextMenu(playlistObject, this.model, MDB, this)
        menu.popup()
    }

    handleDoubleClick(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        this.dispatch("row-double-click", trackObject.id)
    }

    handleClick(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        this.dispatch("row-click", trackObject.id)
        this.selectRow(tableRow.id)
    }

    handleDragEnter(evt) {
        let tableRow = evt.target.closest("tr")
        tableRow && tableRow.classList.add("drop-here")
        evt.preventDefault()
    }

    handleDragLeave(evt) {
        let tableRow = evt.target.closest("tr")
        tableRow && tableRow.classList.remove("drop-here")
        evt.preventDefault()
    }

    handleDragOver(evt) {
        if (evt.preventDefault) {
            evt.preventDefault();
        }
        evt.dataTransfer.dropEffect = 'move';
    }

    handleDragEnd(evt) {

    }

    async handleDrop(evt) {
        let tableRow = this.getEventElement(evt)
        let playlist = this._elements.getElementById(tableRow.id)
        tableRow.classList.remove("drop-here")


        let d = evt.dataTransfer.getData("text/plain")
        playlist = await MDB.playlists.getObjectById(playlist.id)
        let track = await MDB.tracks.getObjectById(d) 
        let confirm = new Menu()
        confirm.append(new MenuItem({
            label: `Add '${track.metadata.title}' to '${playlist.name}'?`, 
            click: async () => { 
                await this.model.appendToPlaylist(playlist._id, track._id)
            }
        }))
        confirm.append(new MenuItem({type:  'separator'}))
        confirm.append(new MenuItem({label: `Cancel`, click: () => {}}))
        confirm.popup({})
    }

    compare_playlists(a, b) {
        if (!a.name) { return -1 }
        if (!b.name) { return 1 }
        let x = a.name.toLowerCase();
        let y = b.name.toLowerCase();
        if (x < y) { return -1; }
        if (x > y) { return 1; }
        return 0;        
    }    

    setList(list_elements) {
        if (list_elements == undefined) {
            list_elements = []
        }

        list_elements.sort(this.compare_playlists) 

        let rowIds = this.setRows(list_elements.map((e) => {
            return this.convert_playlist(e)
        }))

        this._objectid_to_row_id = {}

        Object.keys(rowIds).forEach((id) => {
            this._objectid_to_row_id[rowIds[id].id] = id
        })
        if (this._newPlaylistId) {
        }
    }

    updateElement(playlistObject) {
        let element = this.convert_playlist(playlistObject)
        let rowId = this._objectid_to_row_id[element.id]
        super.updateElement(rowId, element)
        let row = this._row_elements.getElementById(rowId)
        if (row) {
            row.innerHTML = this.renderRow(rowId, element)
        }
    }


    async updateContents(q) {
        this.setList(q)
    }

    async displayModel(model) {
        if (this.model != undefined) {
            this.model.un("content-changed", this.forward_content_changed) 
            this.model.un("object-updated", this.forward_object_changed)
        }
        if (model) {
            this.model = model
            this.model.on("content-changed", this.forward_content_changed) 
            this.model.on("object-updated", this.forward_object_changed)
            this.updateContents(Object.values(await this.model.getAllObjects()))    
        } else {
            this.setList([])
        }
    }
}

class PlaylistListPanel extends DOMElement {
    constructor() {
        super('div')
        let scroller = new DOMElement('div')
        scroller.setStyle({
            overflowY: 'auto',
            width: "100%",
            height: "100%"
        })
        let elements = new DOMElement('table')
        elements.setStyle({
            width: "100%",
            // height: "100%"
        })
        let elementsBody = new DOMElement('tbody')
        elementsBody.setStyle({
            width: "100%",
            // height: "100%"
        })
        elements.appendChild(elementsBody)
        scroller.appendChild(elements)
        this.view = new PlaylistListView(scroller, elements)
        this.view.on("row-click", (playlistId) => {
            this.dispatch('row-click', playlistId)
        })
        scroller.appendChild(this.view)
        this.appendChild(scroller)

    }

    async displayModel(model) {
        await this.view.displayModel(model)
    }

    set_controller(x) {
        this.view.set_controller(x)
    }
}



module.exports = {
    PlaylistListPanel: PlaylistListPanel
}