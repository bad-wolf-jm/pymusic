const { ClusteredListView } = require('ui/listview/cluster')
const { ToggleRenderer, RatingRenderer, TextRenderer, NumberRenderer, DateRenderer} = require('ui/listview/renderer')
const $ = require("jquery")
const { remote } = require('electron')
const { Menu, MenuItem } = remote

class ContextMenu {
    constructor(playlist, model, library, display) {
        this.playlist = playlist
        this.model = model
        this.library = library
        this.display = display

        this.menu = new Menu()
        this.menu.append(new MenuItem({label: 'Edit...', click: async () => {
            let T = this.context_menu_element
            let p = await this.controller.get_playlist_by_id(T)
            let L = new TrackSetModel(MDB, MDB.playlists, T)
            Q.playlist_editor.displayModel(p.name, L)
            Q.show_playlist_editor()
        }}))
        this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Rename', click: () => {
            let T = this.context_menu_element
            let old_value = this.context_menu_cell.innerHTML
            this.context_menu_cell.innerHTML = `<input id="new-playlist-name-${T}" type="text" class="new-playlist" value="${old_value}">`
            let X = document.getElementById(`new-playlist-name-${T}`)
            X.focus()
            X.addEventListener("keyup", async (e) => {
                if (e.key == "Escape") {
                    this.context_menu_cell.innerHTML = old_value
                } else if (e.key == "Enter") {
                    let new_name = X.value
                    if (await this.controller.checkNameAvailability(new_name)) {
                        this.controller.rename_playlist(T, new_name)
                    } else {
                        X.style.color = "#dd0000"
                    }
                } else {
                    let new_name = X.value
                    if (await this.controller.checkNameAvailability(new_name)) {
                        X.style.color = null
                    } else {
                        X.style.color = "#dd0000"
                    }
                }
            })
        }}))
        this.menu.append(new MenuItem({label: 'Duplicate', click: () => {
            let T = this.context_menu_element
            this.controller.duplicate_playlist(T)
        }}))
        this.menu.append(new MenuItem({type: 'separator'}))
        this.menu.append(new MenuItem({label: 'Delete', click: async () => {
            let T = this.context_menu_element
            let playlist = await this.controller.get_playlist_by_id(T)
            let dialog = new Question({
                title: "Delete playlist",
                question: `Delete <i><b>'${playlist.name}'</b></i>? This operation cannot be undone`,
                confirmText: "yes",
                dismissText: 'no',
                confirmAction: async () => {
                    await this.controller.delete_playlist(this.context_menu_element)
                    this.context_menu_element = undefined
                    dialog.close()
                },
                dismissAction: () => {
                    this.context_menu_element = undefined
                    dialog.close()
                },
            })
            dialog.open()    
        }}))
    }

    popup() {
        this.menu.popup({window: remote.getCurrentWindow()})
    }

    close() {
        this.menu.closePopup()
    }

    async append_to_playlist(playlist_id, track_id) {
        return await this.model.appendToPlaylist(playlist_id, track_id)
    }

    async create_playlist(name) {
        return await this.model.createPlaylist(name)
    }

    async rename_playlist(id, new_name) {
        return await this.model.renamePlaylist(id, new_name)
    }

    async duplicate_playlist(id) {
        return await this.model.duplicatePlaylist(id)
    }

    async delete_playlist(id) {
        return await this.model.deletePlaylist(id)
    }

    async checkNameAvailability(name, k) {
        return await this.model.checkNameAvailability(name)
    }

    async get_playlist_by_id(id, k) {
        return this.model.getObjectById(id)
    }


}

class PlaylistsController extends EventDispatcher {
    constructor() {
        super()
        this.queue = undefined
        this.queue_table = undefined
        this.ready_wait_queue = []
        this.views = []
    }

    async setModel(m) {
        this.model = m
        this.model.on("content-changed", (x) => {
            this.dispatch("content-changed", x)
        })
        return this.refresh()
    }

    async refresh(k) {
        this.queue = Object.values(await this.model.getAllObjects())
        this.queue_table = {}
        for (let i=0; i<this.queue.length; i++) {
            this.queue_table[this.queue[i]._id] = this.queue[i]
        }
        this.dispatch("content-changed", this.queue)
    }

    addView(view) {
        this.views.push(view)
    }
    
    ready(func) {
        if (this.queue != undefined) {
            func(this.queue)
        } else {
            this.ready_wait_queue.push(func)
        }
    }

    async append_to_playlist(playlist_id, track_id) {
        return await this.model.appendToPlaylist(playlist_id, track_id)
    }

    async create_playlist(name) {
        return await this.model.createPlaylist(name)
    }

    async rename_playlist(id, new_name) {
        return await this.model.renamePlaylist(id, new_name)
    }

    async duplicate_playlist(id) {
        return await this.model.duplicatePlaylist(id)
    }

    async delete_playlist(id) {
        return await this.model.deletePlaylist(id)
    }

    async checkNameAvailability(name, k) {
        return await this.model.checkNameAvailability(name)
    }

    async get_playlist_by_id(id, k) {
        return this.model.getObjectById(id)
    }

}


class PlaylistListView extends ClusteredListView {
    constructor() {
        super(document.getElementById("playlist-list-elements"), 
              document.getElementById("playlist-list-scroller"))

        // this.dom_id          = dom_ids.list
        // this.controller      = undefined
        // this.view_list_order = []
        this.setupColumnRenderers()
        this._objectid_to_row_id = {}
        this.forward_content_changed = async (q) => {
            await this.updateContents(q)
        }

    }

    begin_add() {
        document.getElementById("new-playlist").style.display = null
    }

    // set_controller(controller) {
    //     this.controller = controller
    //     this.controller.addView(this)
    //     this.controller.on("content-changed", this.set_list.bind(this))
    //     this.controller.ready(this.set_list.bind(this))
    // }


    convert_playlist(playlist_element) {
        return {
            id: playlist_element._id,
            name: playlist_element.name,
            count: Object.keys(playlist_element.elements).length
        }
    }

    setupColumnRenderers() {
        this.addColumnRenderer(new TextRenderer({
            width: "30px",
            color: (obj) => {return null},
            text: (obj) => {return ""}
        }))

        this.addColumnRenderer(new TextRenderer({
            width: "25px",
            color: (obj) => {return null},
            text: (obj) => {return `<i class="fa fa-circle-o arrow-icon"></i>`}
        }))
            
        this.addColumnRenderer(new TextRenderer({
            width: "250px",
            color: (obj) => {return null},
            text: (obj) => {return obj.name}
        }))

        this.addColumnRenderer(new NumberRenderer({
            width: "50px",
            textAlign: "right",
            // marginRight: "5px",
            color: (obj) => {return null},
            text: (obj) => {return obj.count}
        }))

        this.addColumnRenderer(new TextRenderer({
            width: "25px",
            textAlign:"center",
            color: (obj) => {return null},
            text: (obj) => {return `<i class="fa fa-angle-right"></i>`}
        }))
    }


    on_drag_enter(evt) {
        evt.target.parentElement.classList.add("drop-here")
    }

    on_drag_leave(evt) {
        evt.target.parentElement.classList.remove("drop-here")
    }

    on_drag_over(evt) {
        if (evt.preventDefault) {
            evt.preventDefault();
          }
          evt.dataTransfer.dropEffect = 'move';
    }

    on_drag_end(evt) {

    }

    async on_drop(evt) {
        if (evt.stopPropagation) {
            evt.stopPropagation();
        }
        let playlist = evt.target.parentElement
        playlist.classList.remove("drop-here")
        let playlist_id = (playlist.attributes["data-playlist-id"].value)

        let d = evt.dataTransfer.getData("text/plain")
        playlist = await MDB.playlists.getObjectById(playlist_id)
        let track = await MDB.tracks.getObjectById(d) 
        let confirm = new Menu()
        confirm.append(new MenuItem({label: `Add '${track.title}' to '${playlist.name}'?`, click: async () => { 
            await this.controller.append_to_playlist(playlist_id, track)
        }}))
        confirm.append(new MenuItem({type:  'separator'}))
        confirm.append(new MenuItem({label: `Cancel`, click: () => {}}))
        confirm.popup({})
    }

    compare_playlists(a, b) {
        if (!a.name) { return -1 }
        if (!b.name) { return 1 }
        let x = a.name.toLowerCase();
        let y = b.name.toLowerCase();
        if (x < y) { return -1; }
        if (x > y) { return 1; }
        return 0;        
    }    


    setList(list_elements) {
        if (list_elements == undefined) {
            list_elements = []
        }

        list_elements.sort(this.compare_playlists) 

        let rowIds = this.setRows(list_elements.map((e) => {
            return this.convert_playlist(e)
        }))

        this._objectid_to_row_id = {}

        Object.keys(rowIds).forEach((id) => {
            this._objectid_to_row_id[rowIds[id].id] = id
        })
    }

    async updateContents(q) {
        this.setList(q)
    }

    async displayModel(model) {
        if (this.model != undefined) {
            this.model.un("content-changed", this.forward_content_changed) 
        }
        if (model) {
            this.model = model
            this.model.on("content-changed", this.forward_content_changed) 
            this.updateContents(Object.values(await this.model.getAllObjects()))    
        } else {
            this.setList([])
        }
    }
}



module.exports = {
    PlaylistListView: PlaylistListView
}