
class UnorderedListHandler {
    constructor() {
        this._ids = {}
        this._ordering = []
    }

    add(id, element) {
        this._ids[id] = (element || true)
        this._ordering.push(id)
    }

    remove(id) {
        delete this._ids[id]
        let orderingIndex = this._ordering.indexOf(id)
        if (orderingIndex != -1) {
            this._ordering.splice(orderingIndex, 1)
        }
    }
    
    getElementIds() {
        return Object.keys(this._ids)
    }

    getElementById(id) {
        return this._ids[id]
    }

    clear() {
        this._ids = {}
    }

    getRowIndex(id) {
        return this._ordering.indexOf(id)
    }

    getRowId(n) {
        return this._ordering[n]
    }

    getFirst() {
        if (this._ordering.length > 0) {
            return this._ordering[0]
        } else {
            return undefined
        }
    }


    getLast() {
        if (this._ordering.length > 0) {
            return this._ordering[this._ordering.length - 1]
        } else {
            return undefined
        }
    }

    length() {
        return this._ordering.length
    }
}


class BaseListView extends EventDispatcher {
    constructor(element, list_scroller) {
        super()
        this.domElement = element
        this.scrollerElement = list_scroller
        this._selection = new UnorderedListHandler()
        this._dimmed = new UnorderedListHandler()
        this._rows = new UnorderedListHandler()
        this.rowHeight = 30
        this._ignore_dimming = false

        this.domElement.addEventListener('click', (e) => {
            this.handleClick(e)
        });

        this.domElement.addEventListener('dblclick', (e) => {
            this.handleDoubleClick(e)
        });

        this.domElement.addEventListener('dragstart', (e) => {
            this.handleDragStart(e)
        }, false);

        this.domElement.addEventListener('contextmenu', async (e) => {
            e.preventDefault()
            this.handleContextMenu(e)
        });

        this.domElement.addEventListener('dragenter', (e) => {
            this.handleDragEnter(e)
        }, false);

        this.domElement.addEventListener('dragover', (e) => {
            this.handleDragOver(e)
        }, false); 

        this.domElement.addEventListener('dragend',   (e) => {
            this.handleDragEnd(e)
        }, false); 

        this.domElement.addEventListener('drop',     (e) => {
            this.handleDrop(e)
        }, false);

        this.scrollerElement.addEventListener("scroll", (e) => {
            this.handleScroll(e)
        })

    }

    getEventElementId(e) {
        let x = e.target.closest("tr")
        return  x.id 
    }

    async setRows(row_list) {
        this._rows.clear()
        if ((row_list) || (row_list.length)) {
            row_list.forEach((row) => {
                this._rows.add(row.id, row)
            })
        }
    }

    setDimmedRows(idList) {
        if (this._ignore_dimming) {
            return;
        }
        let idSet = {}
        idList.forEach((t) => {idSet[t] = true})
        this._dimmed.getElementIds().forEach((t) => {
            let row = this._rows.getElementById(y)
            row && row.classList.remove("unavailable")
        })
        Object.keys(idSet).forEach((t) => {
            let row = this._rows.getElementById(y)
            this._dimmed.add(t)
            row && row.classList.add("unavailable")
        })
    }

    handleDragScroll(e) {

    }


    handleDragStart(e) {

    }

    handleDradEnter(e) {

    }

    handleDradEnd(e) {
        
    }

    handleDradOver(e) {
        
    }

    handleDrop(e) {
        
    }

    handleDoubleClick(e) {

    }

    handleClick(e) {

    }

    clearSelection() {
        this._selection.getElementIds().forEach((id) => {
            this.unselectTableElement(id)
        })
        this._selection.clear()
    }

    addToSelection(id) {
        this._selection.add(id)
        this.selectTableElement(id)
    }

    selectRow(id) {
        this.clearSelection()
        this.ensureRowVisible(id)
        this.addToSelection(id)
    }

    moveSelection(amount) {
        this.d = Math.sign(amount)
        let last_selection  = this._selection.getLast()
        if (last_selection != undefined) {
            let i = this.getRowIndex(last_selection._id)
            let n
            if (i != -1) {
                n = i + amount
                n = Math.max(n, 0)
                n = Math.min(n, this._selection.length() - 1)
            } else {
                n = 0
            }
            this.selectRow(this.getRowId(n))
        } else {
            this.selectRow(this.getRowId(n))
        }
    }

    moveDown() {
        this.moveSelection(1)
    }

    moveUp() {
        this.moveSelection(-1)
    }

    moveLast() {
        let e = this._rows.getLast()
        if (e != undefined) {
            this.ensureRowVisible(e)
            this.selectRow(e)
        }
    }

    moveFirst() {
        let e = this._rows.getFirst()
        if (e != undefined) {
            this.ensureRowVisible(e)
            this.selectRow(e)
        }
    }

    pageUp() {
        let y = this.scroller.getBoundingClientRect()
        this.scroller.scrollTop -= y.height
    }

    pageDown() {
        let y = this.scroller.getBoundingClientRect()
        scroller.scrollTop += y.height
    }

    getTableElement(id) {
        return this._rows.getElementById(id)
    }

    selectTableElement(id) {
        let e = this.getTableElement(id)      
        if (e != undefined) {
            e.classList.add("selected")
        }
    }

    unselectTableElement(id) {
        let e = this.getTableElement(id)      
        if (e != undefined) {
            e.classList.remove("selected")
        }
    }

    ensureRowVisible(id) {
        let row = this.getTableElement(id)
        let scrollerRect = this.scroller.getBoundingClientRect()
        if (row == undefined) {
            this.scroller.scrollTop += (this.d * this.rowHeight)
        } else {
            let rowRect = row.getBoundingClientRect()
            let offsetTop = (rowRect.y - scrollerRect.y)
            let offsetBottom = offsetTop + rowRect.height
            let y = this.scroller.getBoundingClientRect()
            if (offsetBottom >= y.height) {
                this.scroller.scrollTop += (offsetBottom - y.height)
            } else if (offsetTop < 0) {
                this.scroller.scrollTop += (offsetTop)
            }
        }
    }
}

module.exports = {
    UnorderedListHandler: UnorderedListHandler,
    BaseListView: BaseListView
}
