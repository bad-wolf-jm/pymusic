
class UnorderedListHandler {
    constructor() {
        this._ids = {}
        this._ordering = []
    }

    set(id, element) {
        this._ids[id] = (element || true)
    }

    add(id, element) {
        this._ids[id] = (element || true)
        this._ordering.push(id)
    }

    remove(id) {
        delete this._ids[id]
        let orderingIndex = this._ordering.indexOf(id)
        if (orderingIndex != -1) {
            this._ordering.splice(orderingIndex, 1)
        }
    }
    
    getList() {
        return this._ordering.map((id) => {
            return this._ids[id]
        })
    }

    getElementIds() {
        return Object.keys(this._ids)
    }

    getElementById(id) {
        return this._ids[id]
    }


    clear() {
        this._ids = {}
        this._ordering = []
    }

    getRowIndex(id) {
        return this._ordering.indexOf(id)
    }

    getRowId(n) {
        return this._ordering[n]
    }

    getFirst() {
        if (this._ordering.length > 0) {
            return this._ordering[0]
        } else {
            return undefined
        }
    }

    getLast() {
        if (this._ordering.length > 0) {
            return this._ordering[this._ordering.length - 1]
        } else {
            return undefined
        }
    }

    length() {
        return this._ordering.length
    }
}


class BaseListView extends EventDispatcher {
    constructor(element, list_scroller) {
        super()
        this._viewId = this.createUid()
        this.domElement = element
        this.scrollerElement = list_scroller
        this._selection = new UnorderedListHandler()
        this._dimmed = new UnorderedListHandler()

        // List of <tr> elements
        this._row_elements = new UnorderedListHandler()

        // List of rendered <tr> elements in string form
        this._rendered_rows = new UnorderedListHandler()

        // List of raw elements, unrendered JSON objects
        this._elements = new UnorderedListHandler()

        this.rowHeight = 30
        this._ignore_dimming = false
        this._column_renderers = []

        this.domElement.addEventListener('click', (event) => {
            this.handleClick(event)
        }, false);

        this.domElement.addEventListener('dblclick', (event) => {
            this.handleDoubleClick(event)
        }, false);

        this.domElement.addEventListener('dragstart', (event) => {
            this.handleDragStart(event)
        }, false);

        this.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault()
            this.handleContextMenu(event)
        }, false);

        this.domElement.addEventListener('dragenter', (event) => {
            this.handleDragEnter(event)
        }, false);

        this.domElement.addEventListener('dragover', (event) => {
            this.handleDragOver(event)
        }, false); 

        this.domElement.addEventListener('dragend',   (event) => {
            this.handleDragEnd(event)
        }, false); 

        this.domElement.addEventListener('drop',     (event) => {
            this.handleDrop(event)
        }, false);

        this.scrollerElement.addEventListener("scroll", (event) => {
            this.handleScroll(event)
        }, false)
    }

    createUid() {
        return '_' + Math.random().toString(36).substr(2, 9);
    };


    setRows(object_list) {
        this._rendered_rows.clear()
        this._elements.clear()
        let rowIds = {}
        object_list.forEach((row) => {
            let rowId = this.createUid()
            this._rendered_rows.add(rowId, this.renderRow(rowId, row))
            this._elements.add(rowId, row)
            rowIds[rowId] = row
        })
        return rowIds
    }

    renderHeader() {
        let columns = this._column_renderers.map((renderer) => {
            if (renderer._config.headerTitle) {
                return `<th>${renderer._config.headerTitle}</th>`
            } else {
                return `<th></th>`
            }
        })
        return `<tr id="${this._viewId}-header" style="border:0px solid transparent; margin:0; padding:0">
                    ${columns.join("")}
                </tr>`
    }

    renderRow(rowId, element) {
        let columnIndex = 0
        let columns = this._column_renderers.map((renderer) => {
            columnIndex += 1
            return renderer.render(rowId, columnIndex, element)
        })
        return `<tr id='${rowId}' class="list-group-item row ${this._viewId}" draggable=true>
                    ${columns.join("")}
                </tr>`
    }

    addColumnRenderer(renderer) {
        this._column_renderers.push(renderer)
    }

    getEventElementId(event) {
        let x = e.target.closest("tr")
        return  x.id 
    }

    setRowElements(row_list) {
        this._row_elements.clear()
        if ((row_list) || (row_list.length)) {
            row_list.forEach((row) => {
                this._row_elements.add(row.id, row)
            })
        }
    }

    setDimmedRows(idList) {
        if (this._ignore_dimming) {
            return;
        }
        let idSet = {}
        idList.forEach((t) => {idSet[t] = true})
        this._dimmed.getElementIds().forEach((t) => {
            let row = this._row_elements.getElementById(t)
            row && row.classList.remove("unavailable")
        })
        Object.keys(idSet).forEach((t) => {
            let row = this._row_elements.getElementById(t)
            this._dimmed.add(t)
            row && row.classList.add("unavailable")
        })
    }

    handleContextMenu(event) {

    }

    handleScroll(event) {

    }

    handleDragStart(event) {

    }

    handleDragEnter(event) {

    }

    handleDragEnd(event) {
        
    }

    handleDragOver(event) {
        
    }

    handleDrop(event) {
        
    }

    handleDoubleClick(event) {

    }

    handleClick(event) {

    }

    clearSelection() {
        this._selection.getElementIds().forEach((id) => {
            this.unselectTableElement(id)
        })
        this._selection.clear()
    }

    addToSelection(id) {
        this._selection.add(id)
        this.selectTableElement(id)
    }

    selectRow(id) {
        this.clearSelection()
        this.ensureRowVisible(id)
        this.addToSelection(id)
    }

    moveSelection(amount) {
        this.cancelEdit()
        this.d = Math.sign(amount)
        let last_selection  = this._selection.getLast()
        if (last_selection != undefined) {
            // console.log(last_selection)
            let i = this._rendered_rows.getRowIndex(last_selection)
            let n
            // console.log(i)
            if (i != -1) {
                n = i + amount
                n = Math.max(n, 0)
                n = Math.min(n, this._rendered_rows.length() - 1)
            } else {
                n = 0
            }
            this.selectRow(this._rendered_rows.getRowId(n))
        } else {
            this.selectRow(this._rendered_rows.getRowId(0))
        }
    }

    moveDown() {
        this.moveSelection(1)
    }

    moveUp() {
        this.moveSelection(-1)
    }

    moveLast() {
        let e = this._row_elements.getLast()
        if (e != undefined) {
            this.ensureRowVisible(e)
            this.selectRow(e)
        }
    }

    moveFirst() {
        let e = this._row_elements.getFirst()
        if (e != undefined) {
            this.ensureRowVisible(e)
            this.selectRow(e)
        }
    }

    pageUp() {
        let y = this.scrollerElement.getBoundingClientRect()
        this.scrollerElement.scrollTop -= y.height
    }

    pageDown() {
        let y = this.scrollerElement.getBoundingClientRect()
        this.scrollerElement.scrollTop += y.height
    }

    getTableElement(id) {
        return this._row_elements.getElementById(id)
    }

    selectTableElement(id) {
        let e = this.getTableElement(id)      
        if (e != undefined) {
            e.classList.add("selected")
        }
    }

    unselectTableElement(id) {
        let e = this.getTableElement(id)      
        if (e != undefined) {
            e.classList.remove("selected")
        }
    }

    ensureRowVisible(id) {
        let row = this.getTableElement(id)
        let scrollerRect = this.scrollerElement.getBoundingClientRect()
        if (row == undefined) {
            this.scrollerElement.scrollTop += (this.d * this.rowHeight)
        } else {
            let rowRect = row.getBoundingClientRect()
            let offsetTop = (rowRect.y - scrollerRect.y)
            let offsetBottom = offsetTop + rowRect.height
            let y = this.scrollerElement.getBoundingClientRect()
            if (offsetBottom >= y.height) {
                this.scrollerElement.scrollTop += (offsetBottom - y.height)
            } else if (offsetTop < 0) {
                this.scrollerElement.scrollTop += (offsetTop)
            }
        }
    }

    _editKeypress (e) {
        if (e.key == "Escape") {
            this.cancelEdit()
        } else if (e.key == "Enter") {
            this.saveEdit()
        } else if (e.key == "Alt") {
            if (this.edit_bpm != undefined) {
                let t = this.edit_bpm.tap()
                let bpm = Math.round(t.avg)
                if (!isNaN(bpm)) {
                    this.editValues[editTag].value = bpm
                }
            }
        } else {

        }
    }

    beginEdit() {
        if (this._selection.length() == 1) {
            this.edit_mode = true
            let row_id_to_edit = this._selection.getElementIds()[0]
            let rowToEdit = this._row_elements.getElementById(row_id_to_edit)
            let objectToEdit = this._elements.getElementById(row_id_to_edit)
            this.editValues = {}
            this.oldRowValues = {}
            this.editRowCells = {}
            let firstElementFocused = false
            for (let i = 0; i<this._column_renderers.length; i++) {
                if (this._column_renderers[i]._config.editTag) {
                    let editTag = this._column_renderers[i]._config.editTag
                    let newId = this.createUid()
                    let editor = this._column_renderers[i].renderEditor(newId, objectToEdit)
                    this.editValues[editTag] = newId
                    this.oldRowValues[editTag] = rowToEdit.children[i].innerHTML
                    this.editRowCells[editTag] = rowToEdit.children[i]
                    rowToEdit.children[i].innerHTML = editor
                    this.editValues[editTag] = rowToEdit.children[i].children[0]
                    rowToEdit.children[i].children[0].addEventListener("keyup", (e) => {
                        this._editKeypress(e)
                    })
                    if (!firstElementFocused) {
                        firstElementFocused = true
                        rowToEdit.children[i].children[0].focus()
                    }
                }
            }
        }
    }

    saveEdit() {
        if (this.edit_mode) {
            let values = {}
            Object.keys(this.editValues).forEach((k) => {
                values[k] = this.editValues[k].value
            })
            this.cancelEdit()
            this.dispatch("row-valued-edited", values)
        }
    }

    cancelEdit() {
        if (this.edit_mode) {
            Object.keys(this.editRowCells).forEach((k) => {
                this.editRowCells[k].innerHTML = this.oldRowValues[k]
            })
            this.edit_mode = false
        }
    }

    updateElement(rowId, data) {
        this._elements.set(rowId, data)
        this._rendered_rows.set(rowId, this.renderRow(rowId, data))
    }




}

module.exports = {
    UnorderedListHandler: UnorderedListHandler,
    BaseListView: BaseListView
}
