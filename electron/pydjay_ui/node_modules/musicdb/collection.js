const { EventDispatcher } = require("notify/event_dispatcher")
const { Datastore } = require("nedb-async-await")

var path = require('path');

class CollectionModel extends EventDispatcher {
    constructor(filename) {
        super()
        this.d = new Datastore({
            filename: filename, 
            autoload: true,
            timestampData: true})
    }

    getAllObjects() {
        return this.getObjectsByIds()
    }

    async getObjectsByIds(id_array) {
        let query = (id_array == undefined) ? {} : {_id: {$in: id_array}}
        let objects = await this.d.find(query)
        let result = {}
        objects.forEach((o) => {result[o._id] = o})
        return result
    }

    async getObjectById(id) {
        return (await this.getObjectsByIds([id]))[id]
    }

    async length() {
        return await this.d.count({})        
    }

    async setData(object, new_data) {
        let [num, modified] = await this.d.update({_id: object._id},  {$set: new_data}, {returnUpdatedDocs: true})
        if (num > 0) {
            this.dispatch("object-updated", modified)
        }
        return modified
    }
}


class TrackCollectionModel extends CollectionModel {
    constructor(db, filename) {
        super(filename)
        this.db = db
    }

    async getTracks() {
        return Object.values(await this.getAllObjects())
    }

    getElementById(id) {
        return this.getObjectById(id)
    }

    async getObjectsByIds(id_array) {
        let query = (id_array == undefined) ? {} : {_id: {$in: id_array}}
        let objects = await this.d.find(query)
        let result = {}
        let cover_folder = this.db.getCoverFolder()
        let tracks_folder = this.db.getTracksFolder()
        objects.forEach((track) => {
            track.track.path = path.join(tracks_folder, track.track.filename)
            if (track.metadata.cover) {
                Object.keys(track.metadata.cover).forEach((x) => {
                    track.metadata.cover[x] = path.join(cover_folder, track.metadata.cover[x])
                })
            }
            result[track._id] = track
        })
        return result
    }


    async duration(id_array) {
        let tracks = await this.getObjectsByIds(id_array)
        let dur = 0
        Object.keys(tracks).forEach((track_id) => {
            dur += (tracks[track_id].track.stream_end - tracks[track_id].track.stream_start)
        })
        return dur
    }

    async setData(object, new_data) {
        let [num, modified] = await this.d.update({_id: object._id},  {$set: new_data}, {returnUpdatedDocs: true})

        if (num > 0) {
            let cover_folder = this.db.getCoverFolder()
            let tracks_folder = this.db.getTracksFolder()
            modified.track.path = path.join(tracks_folder, modified.track.filename)
            if (modified.metadata.cover) {
                Object.keys(modified.metadata.cover).forEach((x) => {
                    modified.metadata.cover[x] = path.join(cover_folder, modified.metadata.cover[x])
                })
            }
            this.dispatch("object-updated", modified)
        }
        return modified
    }

    async setTrackMetadata(track, data) {
        await this.setData(track, data)
        return await this.getElementById(track._id)
    }

    async setTags(track, tags) {
        if (tags === null || tags.length == 0) {
            await this.setTrackMetadata(track, {
                "metadata.color": null,
                "metadata.tags": []
            })
        } else {
            let tagIds = tags.map((t) => {return t._id})
            let color = tags[0].color
            await this.setTrackMetadata(track, {
                "metadata.color": color,
                "metadata.tags": tagIds
            })

        }
    }

    async appendTag(track, tag) {
        let tagIdx = track.metadata.tags.indexOf(tag._id)
        if ( tagIdx == -1 ) {
            track.metadata.tags.push(tag._id)
            if (track.metadata.tags.length == 1) {
                await this.setTrackMetadata(track, {
                    "metadata.color": tag.color,
                    "metadata.tags": track.metadata.tags
                })        
            } else {
                await this.setTrackMetadata(track, {
                    "metadata.tags": track.metadata.tags
                })        
            }
        }
    }

    async removeTag(trackObject, tag) {
        let id = tag._id
        if (trackObject.metadata.tags && (trackObject.metadata.tags.indexOf(id) != -1)) {
            let tagIdx = trackObject.metadata.tags.indexOf(id)
            trackObject.metadata.tags.splice(tagIdx, 1)
            let newColor;
            if (tagIdx == 0) {
                if (trackObject.metadata.tags.length > 0) {
                    let topTag = await this.db.tags.getObjectById(trackObject.metadata.tags[0])
                    newColor = topTag.color
                } else {
                    newColor = null
                }
                await this.setTrackMetadata(trackObject, {
                    'metadata.color': newColor,
                    "metadata.tags": trackObject.metadata.tags
                })
            } else {
                await this.setTrackMetadata(trackObject, {
                    "metadata.tags": trackObject.metadata.tags
                })    
            } 
        }
    }
}

class PlaylistCollectionModel extends CollectionModel {

    async checkNameAvailability(name) {
        let count = await this.d.count({name:name})
        return (count == 0)        
    }

    async appendToPlaylist(playlist_id, track) {
        let pl = await this.getObjectById(playlist_id)
        // console.log(track)
        pl.elements[track] = true
        this.setData(pl, {elements: pl.elements})
    }

    async createPlaylist(name) {
        if (await this.checkNameAvailability(name)) {
            let new_playlist = await this.d.insert({name:name, elements:{}})
            this.dispatch("content-changed", Object.values(await this.getAllObjects()))
            return new_playlist
        }
    }

    async renamePlaylist(playlist_id, new_name) {
        if (await this.checkNameAvailability(name)) {
            let pl = await this.getObjectById(playlist_id)
            this.setData(pl, {name: new_name})
            this.dispatch("content-changed", Object.values(await this.getAllObjects()))
            return pl
        }
    }


    async duplicatePlaylist(playlist_id) {
        let pl = await this.getObjectById(playlist_id)
        let i = 1
        while (!(await this.checkNameAvailability(`${pl.name}.${i}`))) {
            i++
        }
        let new_playlist = await this.createPlaylist(`${pl.name}.${i}`)
        return this.setData(new_playlist, {elements: pl.elements})
    }

    async deletePlaylist(playlist_id) {
        await this.d.remove({_id: playlist_id})
        // console.log("removed")
        this.dispatch("content-changed", Object.values(await this.getAllObjects()))
    }
}


class SessionCollectionModel extends CollectionModel {
    async renameSession(sessionId, new_name) {
        let pl = await this.getObjectById(sessionId)
        this.setData(pl, {event: new_name})
        this.dispatch("content-changed", Object.values(await this.getAllObjects()))
        return pl
    }
}


module.exports = {
    CollectionModel: CollectionModel,
    TrackCollectionModel: TrackCollectionModel,
    PlaylistCollectionModel: PlaylistCollectionModel,
    SessionCollectionModel: SessionCollectionModel
}