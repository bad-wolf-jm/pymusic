const { EventDispatcher } = require("event_dispatcher")


class TrackSetModel extends EventDispatcher {

    constructor(db, collection, id) {
        super()
        this.db = db
        this.collection = collection
        this.id = id

        this.db.tracks.on("object-updated", (x) => {
            this.dispatch("object-updated", x)
        })
    }

    async _getElements() {
        let q = await this.collection.getObjectById(this.id)
        if (q != undefined) {
            return {ordering: q.ordering, elements: q.elements}
        } else {
            return {ordering: [], elements: {}}
        }
    }

    async isEmpty() {
        let element_list = await this._getElements()
        if ((this.ordering != undefined) && (this.ordering.indexOf(null) == 0)) {
            return true
        } else if ((this.ordering != undefined) && (this.ordering.length == 0)) {
            return true
        } else {
            return Object.keys(element_list.elements).length == 0
        }
    }

    async _setElements(ordering, elements, silent) {
        let n = await this.collection.d.update({_id: this.id}, 
            {$set: {elements: elements, ordering: ordering}}, 
            {returnUpdatedDocs: true})    
        if (!silent) {
            this.dispatch("content-changed", await this.getTracks())
        }
        return n
    }

    async pop() {
        let element_list = await this._getElements()
        if ((element_list.ordering == undefined) || (element_list.ordering.length > 0) && (element_list.ordering[0] != null)) {
            let next_id = element_list.ordering.shift()
            element_list.elements[next_id] = undefined
            await this._setElements(element_list.ordering, element_list.elements)
            return await this.db.getTrackById(next_id)
        }
    
    }

    async append(track, data) {
        if ((this.insert_guard == undefined) || (await this.insert_guard(track))) {
            let element_list = await this._getElements()
            element_list.elements[track._id] = (data || true)
            if (element_list.ordering != undefined) {
                element_list.ordering.push(track._id)
            }
            return await this._setElements(element_list.ordering, element_list.elements)    
        }

    }

    async insert(track, position, data) {
        if ((this.insert_guard != undefined) && (await this.insert_guard(track))) {
            let element_list = await this._getElements()
            element_list.elements[track._id] = (data || true)
            if (element_list.ordering != undefined) {
                element_list.ordering.splice(position, 0, track._id)
            }
            return this._setElements(element_list.ordering, element_list.elements)
        }
    }

    async remove(track) {
        let element_list = await this._getElements()
        element_list.elements[track._id] = undefined
        if (element_list.ordering != undefined) {
            let idx = element_list.ordering.indexOf(track._id)
            if (idx != -1) {
                element_list.ordering.splice(idx, 1)
            } 
        }
        return this._setElements(element_list.ordering, element_list.elements)
    }

    async reorder(new_order, silent) {
        let element_list = await this._getElements()
        if (element_list.ordering.length == new_order.length) {
            if (new_order.every((x) => {return (x == null) || (element_list.elements[x])})) {
                this._setElements(new_order, element_list.elements, true)

                if (!silent) {
                    this.dispatch("reorder", await this.getTracks())
                } 
            }
        }
    }

    async getTracks() {
        let e = await this._getElements()
        let trackIds = Object.keys(e.elements).filter((x) => {return e.elements[x]})
        let tracks = await this.db.getTracksByIds(trackIds)
        if (e.ordering != undefined) {
            let list = []
            e.ordering.forEach((id) => {
                if (id == null) {
                    list.push(null)
                } else {
                    list.push(tracks[id])
                }
            })
            return list
        } else {
            return Object.values(tracks)
        }
    }

    async getTrackIds() {
        let e = await this._getElements()
        let ids = Object.keys(e.elements).filter((x) => {return e.elements[x]})
        return ids
    }

    async length() {
        let e = await this._getElements()
        if (e.ordering == undefined) {
            return Object.keys(e.elements).length
        } else {
            let first_null = e.ordering.indexOf(null)
            if (first_null != -1) {
                return first_null
            } else {
                return e.ordering.length
            }
        }
    }

    async duration() {
        let e = await this._getElements()
        if (e.ordering == undefined) {
            return this.db.tracks.duration(Object.keys(e.elements))
        } else {
            let first_null = e.ordering.indexOf(null)
            if (first_null != -1) {
                return this.db.tracks.duration(e.ordering.slice(0, first_null))
            } else {
                return this.db.tracks.duration(e.ordering)
            }
        }
    }

    async getElementById(id) {
        return await this.db.getTrackById(id)
    }

    async setTrackMetadata(track, data) {
        let e = await this._getElements()
        if (e.elements[track._id] != undefined) {
            this.db.tracks.setData(track, data)
        }
    }

}

module.exports = {
    TrackSetModel: TrackSetModel
}