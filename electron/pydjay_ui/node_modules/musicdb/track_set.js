const { EventDispatcher } = require("event_dispatcher")


class TrackSetModel extends EventDispatcher {

    constructor(db, collection, id) {
        super()
        this.db = db
        this.collection = collection
        this.id = id
    }

    async _getElements() {
        let q = await this.collection.getObjectById(this.id)
        if (q != undefined) {
            return {ordering: q.ordering, elements: q.elements}
        } else {
            return {ordering: [], elements: {}}
        }
    }

    isEmpty() {
        let element_list = Object.keys(this._getElements())
        return (element_list.length == 0)
    }

    async _setElements(ordering, elements) {
        let n = await this.collection.update({_id: this.id}, 
            {$set: {elements: elements, ordering: ordering}}, 
            {returnUpdatedDocs: true})    
        this.dispatch("content-changed", n)
        return n
    }

    async append(track, data) {
        let element_list = this._getElements()
        element_list.elements[track._id] = data
        if (element_list.ordering != undefined) {
            element_list.ordering.push(track._id)
        }
        return this._setElements(element_list.ordering, element_list.elements)
    }

    async insert(track, position, data) {
        let element_list = this._getElements()
        element_list.elements[track._id] = data
        if (element_list.ordering != undefined) {
            element_list.ordering.splice(position, 0, track._id)
        }
        return this._setElements(element_list.ordering, element_list.elements)
    }

    async remove(track) {
        let element_list = this._getElements()
        element_list.elements[track._id] = undefined
        if (element_list.ordering != undefined) {
            idx = element_list.ordering.indexOf(track._id)
            if (idx != -1) {
                element_list.ordering.splice(idx, 1)
            }
        }
        return this._setElements(element_list.ordering, element_list.elements)
    }

    async getTracks() {
        let e = await this._getElements()
        let tracks = await this.db.getTracksByIds(Object.keys(e))
        if (e.ordering != undefined) {
            let list = []
            e.ordering.forEach((id) => {
                if (id == null) {
                    list.push(null)
                } else {
                    list.push(tracks[id])
                }
            })
            return list
        } else {
            return Object.values(tracks)
        }
    }

    async length() {
        let e = this._getElements()
        if (e.ordering == undefined) {
            return Object.keys(e.elements).length
        } else {
            first_null = e.ordering.indexOf(null)
            if (first_null != -1) {
                return first_null
            } else {
                return e.ordering.length
            }
        }
    }

    async duration() {
        let e = this._getElements()
        if (e.ordering == undefined) {
            return this.db.tracks.duration(Object.keys(e.elements)) //.length
        } else {
            first_null = e.ordering.indexOf(null)
            if (first_null != -1) {
                return this.db.tracks.duration(e.ordering.slice(0, first_null))
            } else {
                return this.db.tracks.duration(e.ordering)
            }
        }
    }
}

module.exports = {
    // ObjectSetModel: ObjectSetModel,
    TrackSetModel: TrackSetModel
}