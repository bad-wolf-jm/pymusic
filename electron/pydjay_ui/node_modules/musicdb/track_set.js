const { EventDispatcher } = require("event_dispatcher")


class TrackSetModel extends EventDispatcher {

    constructor(db, collection, id) {
        super()
        this.db = db
        this.collection = collection
        this.id = id
    }

    async _getElements() {
        let q = await this.collection.getObjectById(this.id)
        if (q != undefined) {
            return {ordering: q.ordering, elements: q.elements}
        } else {
            return {ordering: [], elements: {}}
        }
    }

    async isEmpty() {
        let element_list = await this._getElements()
        if ((this.ordering != undefined) && (this.ordering.indexOf(null) == 0)) {
            return true
        } else if ((this.ordering != undefined) && (this.ordering.length == 0)) {
            return true
        } else {
            return Object.keys(element_list.elements).length == 0
        }
    }

    async _setElements(ordering, elements) {
        let n = await this.collection.d.update({_id: this.id}, 
            {$set: {elements: elements, ordering: ordering}}, 
            {returnUpdatedDocs: true})    
        this.dispatch("content-changed", await this.getTracks())
        return n
    }

    async pop() {
        let element_list = await this._getElements()
        if ((element_list.ordering != undefined) && (element_list.ordering.length > 0) && (element_list.ordering[0] != null)) {
            let next_id = element_list.ordering.shift()
            element_list.elements[next_id] = undefined
            await this._setElements(element_list.ordering, element_list.elements)
            return await this.db.getTrackById(next_id)
        }
    
    }

    async append(track, data) {
        let element_list = await this._getElements()
        // console.log(track, data)
        element_list.elements[track._id] = (data || true)
        if (element_list.ordering != undefined) {
            element_list.ordering.push(track._id)
        }
        return await this._setElements(element_list.ordering, element_list.elements)
    }

    async insert(track, position, data) {
        let element_list = await this._getElements()
        element_list.elements[track._id] = (data || true)
        if (element_list.ordering != undefined) {
            element_list.ordering.splice(position, 0, track._id)
        }
        return this._setElements(element_list.ordering, element_list.elements)
    }

    async remove(track) {
        let element_list = await this._getElements()
        element_list.elements[track._id] = undefined
        if (element_list.ordering != undefined) {
            idx = element_list.ordering.indexOf(track._id)
            if (idx != -1) {
                element_list.ordering.splice(idx, 1)
            }
        }
        return this._setElements(element_list.ordering, element_list.elements)
    }

    async reorder(new_order, silent) {
        let element_list = await this._getElements()
        if (element_list.ordering.length == new_order.length) {
            if (new_order.every((x) => {return (x == null) || (element_list.elements[x])})) {
                this._setElements(new_order, element_list.elements)
                !silent && this.dispatch("reorder", await this.getTracks())
            }
        }
    }

    async getTracks() {
        let e = await this._getElements()
        console.log("QUEUE")
        let tracks = await this.db.getTracksByIds(Object.keys(e.elements))
        if (e.ordering != undefined) {
            let list = []
            e.ordering.forEach((id) => {
                if (id == null) {
                    console.log("NULL")
                    list.push(null)
                } else {
                    console.log(id, )
                    list.push(tracks[id])
                }
            })
            return list
        } else {
            return Object.values(tracks)
        }
    }

    async length() {
        let e = await this._getElements()
        // console.log(e)
        if (e.ordering == undefined) {
            return Object.keys(e.elements).length
        } else {
            let first_null = e.ordering.indexOf(null)
            if (first_null != -1) {
                return first_null
            } else {
                return e.ordering.length
            }
        }
    }

    async duration() {
        let e = await this._getElements()
        if (e.ordering == undefined) {
            return this.db.tracks.duration(Object.keys(e.elements)) //.length
        } else {
            let first_null = e.ordering.indexOf(null)
            if (first_null != -1) {
                return this.db.tracks.duration(e.ordering.slice(0, first_null))
            } else {
                return this.db.tracks.duration(e.ordering)
            }
        }
    }

    async getElementById(id) {
        return await this.db.getTrackById(id)
    }



}

module.exports = {
    // ObjectSetModel: ObjectSetModel,
    TrackSetModel: TrackSetModel
}