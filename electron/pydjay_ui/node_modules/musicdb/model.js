const { EventDispatcher } = require("event_dispatcher")

const { CollectionModel, TrackCollectionModel, PlaylistCollectionModel, SessionCollectionModel } = require("./collection.js")
const { QueueModel } = require("./queue.js")
const { SessionModel } = require("./session.js")
const { QueryModel, FunctionModel }  = require("./playlist.js")
const { TrackSetModel } = require("./track_set.js")
const { homedir } = require("os")
var path = require('path');
var fs = require('fs-extra')
var Jimp = require("jimp");
var jsmediatags = require("jsmediatags");
const { mp3Duration } = require("fileinfo/mp3_fileinfo")

function parse_tag(filename, tag) {
    var p_tag = {
        filename: filename,
        title: tag.tags.title,
        artist: tag.tags.artist,
        album: tag.tags.album,
        genre: tag.tags.genre,
        year: tag.tags.year,
        comment: tag.tags.comment ? tag.tags.comment.text : "",
        picture: tag.tags.picture,
        loved: 0,
        rating: 0
    }
    if (tag.type == 'ID3') {
        p_tag.bpm = (tag.tags.TBPM != undefined) ? tag.tags.TBPM.data : null;
    }
    let bit_info = mp3Duration(filename)
    p_tag.duration = bit_info.duration
    p_tag.file_size = bit_info.file_size
    p_tag.bit_rate = bit_info.bit_rate
    p_tag.samplerate = bit_info.samplerate
    return p_tag;
}


function read_metadata(filename) {
    return new Promise(function(resolve, reject) {
      jsmediatags.read(filename, {
        onSuccess: function(tag) {
          resolve(parse_tag(filename, tag));
        },
        onError: function(error) {
          reject(error);
        }
      });
    });
  }


class MusicDatabase extends EventDispatcher {
    constructor(name, root) {
        super()
        this._name = name
        this._path = path.join(root ? root : homedir(), ".pymusic-library", name)
        this.tracks = new TrackCollectionModel(this, path.join(this._path, "library", "tracks.json"))
        this.sessions  = new SessionCollectionModel(path.join(this._path, "library", "sessions.json"))
        this.playlists = new PlaylistCollectionModel(path.join(this._path, "library", "playlists.json"))
        this.state = new CollectionModel(path.join(this._path, "library", "state.json"))
        this.tags = new CollectionModel(path.join(this._path, "library", "tags.json"))
        this.queue = new QueueModel(this, this.state, "queue")
        this.current_session = new SessionModel(this, this.state, "session")

        this.never_played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.stats.play_count == undefined) || (this.stats.play_count == 0)
        }})

        this.played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.stats.play_count != undefined) && (this.stats.play_count > 0)
        }})

        this.suggested = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTracks()
            let played_tracks = await this.current_session.getTracks()
            let idx = {}
            queued_tracks.forEach((e) => {
                if ((e != null) && (e.stats.relations != undefined)) {
                    if (e.stats.relations != undefined) {
                        Object.keys(e.stats.relations).forEach((k) => {idx[k] = true})
                    }
                }
            })
            played_tracks.forEach((e) => {    
                if ((e != null) && (e.stats.relations != undefined)) {
                    if (e.stats.relations != undefined) {
                        Object.keys(e.stats.relations).forEach((k) => {idx[k] = true})
                    }
                }                
            })
            return Object.keys(idx)
        })

        this.unavailable = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTrackIds()
            let played_tracks = await this.current_session.getTrackIds()
            let unavailable_tracks = await this.unavailable_tracks.getTrackIds()
            let idx = {}
            queued_tracks.forEach((x) => {idx[x] = true})
            played_tracks.forEach((x) => {idx[x] = true})
            unavailable_tracks.forEach((x) => {idx[x] = true})
            return Object.keys(idx)
        })

        this.shortlisted_tracks = new TrackSetModel(this, this.state, "shortlist")
        this.unavailable_tracks = new TrackSetModel(this, this.state, "unavailable")

        this.queue.insert_guard = async (track) => {
            let id = track._id
            let queue = await this.queue._getElements()
            let session_tracks = await this.current_session._getElements()
            let unavailable_tracks = await this.unavailable_tracks._getElements()
            return (queue.elements[id] == undefined) && (session_tracks.elements[id] == undefined) && (unavailable_tracks.elements[id] == undefined)
        }
    }


    async initialize() {
        await this.state.d.insert({_id: "queue", elements:{}, ordering:[null]})
        await this.state.d.insert({_id: "session", elements:{}, ordering:[]})
        await this.state.d.insert({_id: "shortlist", elements:{}})
        await this.state.d.insert({_id: "unavailable", elements:{}})
        await this.state.d.insert({
            _id: "settings", 
            track_gap: 2000,
            audio_devices: {},
            audio_setup: {
                main_master: null,
                main_headset: null,
                prelisten: null
            },
            current_track: {
                _id: null,
                current_position: null
            },
        })
    }

    getCoverFolder() {
        return path.join(this._path, "covers")
    }

    getTracksFolder() {
        return path.join(this._path, "tracks")
    }


    async discardCurrentSession() {
        this.current_session._setElements([], {})
    }

    async saveCurrentSession(name) {
        let session_tracks = await this.current_session._getElements()
        let n = await this.sessions.d.insert({
            event: name,
            date_start: new Date(Object.values(session_tracks.elements).map((e) => {
                return e.time_start
            }).reduce((x,y) => {
                return Math.min(x,y)
            })),
            date_end: new Date(Object.values(session_tracks.elements).map((e) => {
                return e.time_end
            }).reduce((x,y) => {
                return Math.min(x,y)
            })),
            ordering: session_tracks.ordering,
            elements: session_tracks.elements
        })
        this.sessions.dispatch("content-changed", Object.values(await this.sessions.getAllObjects()))
        for (let i = 0; i < session_tracks.ordering.length - 1; i++) {
            let track = await this.tracks.getElementById(session_tracks.ordering[i])
            let related = await this.tracks.getElementById(session_tracks.ordering[i+1])
            if (track.stats.relations[related._id] != undefined) {
                track.stats.relations[related._id] += 1
            } else {
                track.stats.relations[related._id] = 1
            }
            await this.tracks.setData(track, {"stats.relations": track.stats.relations})
            await this.discardCurrentSession()
        }
    }

    async getSettings() {
        return (await this.state.d.find({_id: "settings"}))[0]
    }

    async getAudioSetup() {
        let settings = await this.getSettings()
        return settings.audio_setup || {}
    }

    async getAudioDevices() {
        let settings = await this.getSettings()
        return settings.audio_devices || {}
    }


    async getTracksByIds(id_array) {
        let track_objects = await this.tracks.getObjectsByIds(id_array)
        return track_objects
    }

    async getTrackById(id) {
        return (await this.getTracksByIds([id]))[id]
    }

    async duration(id_array) {
        let tracks = await this.getTracksByIds(id_array)
        let dur = 0
        tracks.forEach((track) => {
            dur += (track.stream_end - track.stream_start)
        })
        return dur
    }

    async setTrackData(track, new_data) {
        let [num, modified] = await this.tracks.update(
            {"_id": track._id}, 
            {$set: new_data}, 
            {returnUpdatedDocs: true})
        if (num > 0) {
            this.dispatch("track-metadata-changed". modified)
        }
        return modified
    }

    insertTrack(track) {
        return this.tracks.insert(track)    
    }

    getFileExtension(f_name) {
        return f_name.slice((Math.max(0, f_name.lastIndexOf(".")) || Infinity) + 1);
    }


    async addFile(file_path) {
        let file_metadata = await read_metadata(file_path)
        let new_track = await this.tracks.d.insert({
            metadata: {
                title: file_metadata.title,
                artist: file_metadata.artist,
                album: file_metadata.album,
                genre: file_metadata.genre,
                year: file_metadata.year,
                tags: [],
                color: null,
                comment: file_metadata.comment,            
            },
            track: {
                duration: file_metadata.duration,
                stream_start: 0,
                stream_end: file_metadata.duration,
                bitrate: file_metadata.bit_rate,
                samplerate: file_metadata.samplerate,
                bpm: file_metadata.bpm,
                size: file_metadata.file_size,
            },
            stats: {
                loved: 0,
                rating: 0,
                play_count: 0,
                last_played: null,
                relations: {}
            }
        })
        let trackId = new_track._id
        let track_filename = `${trackId}.${this.getFileExtension(file_path)}`
        await fs.copy(file_path, path.join(this.getTracksFolder(), track_filename))
        await this.tracks.d.update({_id: trackId}, {$set: {"track.filename": track_filename}})

        if (file_metadata.picture != undefined) {
            let image_type = file_metadata.picture.format;
            let extensions = {
                'image/jpeg': 'jpg',
                'image/png': 'png'
            }
            if (image_type in extensions) {
                let image = await Jimp.read(new Buffer(file_metadata.picture.data))
                let ext = extensions[image_type];
                let root = this.getCoverFolder()

                if (image != null) {
                    image.write(`${path.join(root, `${trackId}_original.${ext}`)}`);
                    image.resize(320,320).write(`${path.join(root, `${trackId}_large.${ext}`)}`)
                    image.resize(160,160).write(`${path.join(root, `${trackId}_medium.${ext}`)}`)
                    image.resize(100,100).write(`${path.join(root, `${trackId}_small.${ext}`)}`)   
                    await this.tracks.d.update({_id: trackId}, {$set: {
                        "metadata.cover.original": `${trackId}_original.${ext}`,
                        "metadata.cover.large": `${trackId}_large.${ext}`,
                        "metadata.cover.medium": `${trackId}_medium.${ext}`,
                        "metadata.cover.small": `${trackId}_small.${ext}`
                    }})
                }
            }  
        }
        this.tracks.dispatch("content-changed", await this.tracks.getTracks())
        return this.getTrackById(trackId)

    }

    async createTag(name, color) {
        let newTag = await this.tags.d.insert({name: name, color: color})
        return newTag
    }

    async updateTag(id, name, color) {
        let tagObject = await this.tags.getObjectById(id)
        if (tagObject) {
            let oldColor = tagObject.color
            await this.tags.setData(tagObject, {
                name: name, 
                color: color
            })
            if (oldColor != color) {
                Object.values(await this.tracks.getAllObjects()).forEach(async (trackObject) => {
                    if (trackObject.metadata.tags && (trackObject.metadata.tags[0]==id)) {
                        await this.tracks.setData(trackObject, {
                            "metadata.color": color
                        })
                    }
                })
            }
        }
        return tagObject
    }

    async removeTag(id) {
        let tagObject = await this.tags.getObjectById(id)
        if (tagObject) {
            Object.values(await this.tracks.getAllObjects()).forEach(async (trackObject) => {
                await this.tracks.removeTag(trackObject, tagObject)
            })
            this.tags.d.remove({_id: tagObject._id})
        }
        return tagObject
    }
}

module.exports = {
    MusicDatabase: MusicDatabase
}