const { EventDispatcher } = require("event_dispatcher")

const { CollectionModel, TrackCollectionModel, PlaylistCollectionModel } = require("./collection.js")
const { QueueModel } = require("./queue.js")
const { SessionModel } = require("./session.js")
const { PlaylistModel, QueryModel, FunctionModel }   = require("./playlist.js")
const { TrackSetModel } = require("./track_set.js")

var path = require('path');


class MusicDatabase extends EventDispatcher {
    constructor(name) {
        super()
        this.tracks = new TrackCollectionModel(path.join(".ds", name, "tracks.json"))
        this.playback_logs = new CollectionModel(path.join(".ds", name, "playback_logs.json"))
        this.sessions = new CollectionModel(path.join(".ds", name, "sessions.json"))
        this.playlists = new PlaylistCollectionModel(path.join(".ds", name, "playlists.json"))
        this.state = new CollectionModel(path.join(".ds", name, "state.json"))
        this.queue = new QueueModel(this, this.state, "queue")
        this.current_session = new SessionModel(this, this.state, "session")
        this.never_played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history == undefined) || (this.history.length == 0)
        }})
        this.played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history != undefined) && (this.history.length > 0)
        }})

        this.suggested = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTracks()
            let played_tracks = await this.current_session.getTracks()
            let idx = {}
            queued_tracks.forEach((e) => {
                if (e != null) {
                    idx[e._id] = true
                }
            })
            played_tracks.forEach((e) => {    
                idx[e._id] = true
                
            })
            return Object.keys(idx)
        })

        this.shortlisted_tracks = new TrackSetModel(this, this.state, "shortlist")
        this.unavailable_tracks = new TrackSetModel(this, this.state, "unavailable")
    }


    queueIsEmpty() {
        let current_queue = this.getQueue().q
        return (current_queue[0] == null)
    }

    async createPlaylist(name, description, tracks) {
        let new_playlist = {name: name, description: description, tracks: {}}
        tracks.forEach((t) => {new_playlist.tracks[t._id] = true})
        let playlist = await this.playlists.insert(new_playlist)
        this.dispatch("playlist-created", playlist)
    }

    async renamePlaylist(playlist, name) {
        let p = await this.playlists.update(
            {_id: playlist._id}, 
            {$set: {name: name}}, 
            {returnUpdatedDocs: true})
        this.dispatch("playlist-updated", p)
    }

    async duplicatePlaylist(playlist) {
        this.createPlaylist(
            playlist.name + " (duplicate)", 
            playlist.description, 
            playlist.tracks)

    }

    async deletePlaylist(playlist) {
        await this.playlists.remove({_id: playlist._id}, {})
        this.dispatch("playlist-deleted", playlist)
    }

    async setPlaylistTracks(playlist, tracks) {
        playlist.tracks = {}
        tracks.forEach((t) => {playlist.tracks[t._id] = true})
        let p = await this.playlists.update(
            {_id:playlist._id}, 
            {$set: {tracks:playlist.tracks}}, 
            {returnUpdatedDocs: true})
        this.dispatch("playlist-updated", p)
    }

    getSettings() {
        return this.state.find({_id: "settings"})
    }

    async getQueue() {
        let q = await this.state.find({_id: "queue"})
        return new Queue(this, q)
    }

    getCurrentSession() {
        return this.state.find({_id: "current_session"})
    }

    getUnavailableTracks() {
        return this.state.find({_id: "unavailable"})
    }

    getShortList() {
        return this.state.find({_id: "shortlist"})
    }

    getAllTracks() {
        return this.tracks.find({})
    }

    getTracksByIds(id_array) {
        return this.tracks.getObjectsByIds(id_array)
    }

    async getTrackById(id) {
        // console.log("ID=", id)
        // console.log("value=", (await this.getTracksByIds([id])))
        return (await this.getTracksByIds([id]))[id]
    }

    async getAllPlaylists() {
        let sessions = await this.playlists.find({})
        return sessions.map((s) => {return new Playlist(this, s)})
    }

    async getAllSessions() {
        let sessions = await this.sessions.find({})
        return sessions.map((s) => {return new Session(this, s)})
    }

    async duration(id_array) {
        let tracks = await this.getTracksByIds(id_array)
        let dur = 0
        tracks.forEach((track) => {
            dur += (track.bounds.end - track.bounds.start)
        })
        return dur
    }

    async setTrackData(track, new_data) {
        let [num, modified] = await this.tracks.update(
            {"_id": track._id}, 
            {$set: new_data}, 
            {returnUpdatedDocs: true})
        if (num > 0) {
            this.dispatch("track-metadata-changed". modified)
        }
        return modified
    }

    insertTrack(track) {
        return this.tracks.insert(track)    
    }
}


module.exports = {
    MusicDatabase: MusicDatabase
}