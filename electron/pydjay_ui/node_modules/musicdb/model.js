const { EventDispatcher } = require("event_dispatcher")

const { CollectionModel, TrackCollectionModel, PlaylistCollectionModel } = require("./collection.js")
const { QueueModel } = require("./queue.js")
const { SessionModel } = require("./session.js")
const { PlaylistModel, QueryModel, FunctionModel }   = require("./playlist.js")
const { TrackSetModel } = require("./track_set.js")

var path = require('path');


class MusicDatabase extends EventDispatcher {
    constructor(name) {
        super()
        this.tracks = new TrackCollectionModel(path.join(".ds", name, "tracks.json"))
        this.playback_logs = new CollectionModel(path.join(".ds", name, "playback_logs.json"))
        this.sessions  = new CollectionModel(path.join(".ds", name, "sessions.json"))
        this.playlists = new PlaylistCollectionModel(path.join(".ds", name, "playlists.json"))
        this.state = new CollectionModel(path.join(".ds", name, "state.json"))
        this.queue = new QueueModel(this, this.state, "queue")
        this.current_session = new SessionModel(this, this.state, "session")
        this.never_played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history == undefined) || (this.history.length == 0)
        }})
        this.played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history != undefined) && (this.history.length > 0)
        }})

        this.suggested = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTracks()
            let played_tracks = await this.current_session.getTracks()
            let idx = {}
            queued_tracks.forEach((e) => {
                if ((e != null) && (e.relations != undefined)) {
                    if (e.relations != undefined) {
                        Object.keys(e.relations).forEach((k) => {idx[k] = true})
                    }
                }
            })
            played_tracks.forEach((e) => {    
                if ((e != null) && (e.relations != undefined)) {
                    if (e.relations != undefined) {
                        Object.keys(e.relations).forEach((k) => {idx[k] = true})
                    }
                }                
            })
            return Object.keys(idx)
        })

        this.shortlisted_tracks = new TrackSetModel(this, this.state, "shortlist")
        this.unavailable_tracks = new TrackSetModel(this, this.state, "unavailable")


        this.queue.insert_guard = async (track) => {
            //console.log(track)
            let id = track._id
            let queue = await this.queue._getElements()
            let session_tracks = await this.current_session._getElements()
            let unavailable_tracks = await this.unavailable_tracks._getElements()
            return (queue.elements[id] == undefined) && (session_tracks.elements[id] == undefined) && (unavailable_tracks.elements[id] == undefined)
        }
    }


    async discardCurrentSession() {
        this.current_session._setElements([], {})
    }

    async saveCurrentSession(name, location, address) {
        let session_tracks = await this.current_session._getElements()
        let n = await this.sessions.d.insert({
            event: name,
            location: location,
            address: address,
            date_start: new Date(Object.values(session_tracks.elements).map((e) => {return e.time_start}).reduce(Math.max(x, y))),
            date_end:   new Date(Object.values(session_tracks.elements).map((e) => {return e.time_end}).reduce(Math.min(x, y))),
            ordering: session_tracks.ordering,
            elements: session_tracks.elements
        })
        this.sessions.dispatch("content-changed", Object.values(this.sessions.getAllObjects()))
        for (let i = 0; i < session_tracks.ordering.length - 1; i++) {
            let track = await this.tracks.getElementById(session_tracks.ordering[i])
            let related = await this.tracks.getElementById(session_tracks.ordering[i+1])
            if (track.relations[related._id] != undefined) {
                track.relations[related._id] += 1
            } else {
                track.relations[related._id] = 1
            }
            await this.tracks.setData(track, {relations: track.relations})
            await this.discardCurrentSession()
        }
    }

    // queueIsEmpty() {
    //     let current_queue = this.getQueue().q
    //     return (current_queue[0] == null)
    // }

    // async createPlaylist(name, description, tracks) {
    //     let new_playlist = {name: name, description: description, tracks: {}}
    //     tracks.forEach((t) => {new_playlist.tracks[t._id] = true})
    //     let playlist = await this.playlists.insert(new_playlist)
    //     this.dispatch("playlist-created", playlist)
    // }

    // async renamePlaylist(playlist, name) {
    //     let p = await this.playlists.update(
    //         {_id: playlist._id}, 
    //         {$set: {name: name}}, 
    //         {returnUpdatedDocs: true})
    //     this.dispatch("playlist-updated", p)
    // }

    // async duplicatePlaylist(playlist) {
    //     this.createPlaylist(
    //         playlist.name + " (duplicate)", 
    //         playlist.description, 
    //         playlist.tracks)

    // }

    // async deletePlaylist(playlist) {
    //     await this.playlists.remove({_id: playlist._id}, {})
    //     this.dispatch("playlist-deleted", playlist)
    // }

    // async setPlaylistTracks(playlist, tracks) {
    //     playlist.tracks = {}
    //     tracks.forEach((t) => {playlist.tracks[t._id] = true})
    //     let p = await this.playlists.update(
    //         {_id:playlist._id}, 
    //         {$set: {tracks:playlist.tracks}}, 
    //         {returnUpdatedDocs: true})
    //     this.dispatch("playlist-updated", p)
    // }

    getSettings() {
        return this.state.find({_id: "settings"})
    }

    // async getQueue() {
    //     let q = await this.state.find({_id: "queue"})
    //     return new Queue(this, q)
    // }

    // getCurrentSession() {
    //     return this.state.find({_id: "current_session"})
    // }

    // getUnavailableTracks() {
    //     return this.state.find({_id: "unavailable"})
    // }

    // getShortList() {
    //     return this.state.find({_id: "shortlist"})
    // }

    // getAllTracks() {
    //     return this.tracks.find({})
    // }

    getTracksByIds(id_array) {
        return this.tracks.getObjectsByIds(id_array)
    }

    async getTrackById(id) {
        // console.log("ID=", id)
        // console.log("value=", (await this.getTracksByIds([id])))
        return (await this.getTracksByIds([id]))[id]
    }

    // async getAllPlaylists() {
    //     let sessions = await this.playlists.find({})
    //     return sessions.map((s) => {return new Playlist(this, s)})
    // }

    // async getAllSessions() {
    //     let sessions = await this.sessions.find({})
    //     return sessions.map((s) => {return new Session(this, s)})
    // }

    async duration(id_array) {
        let tracks = await this.getTracksByIds(id_array)
        let dur = 0
        tracks.forEach((track) => {
            dur += (track.stream_end - track.stream_start)
        })
        return dur
    }

    async setTrackData(track, new_data) {
        let [num, modified] = await this.tracks.update(
            {"_id": track._id}, 
            {$set: new_data}, 
            {returnUpdatedDocs: true})
        if (num > 0) {
            this.dispatch("track-metadata-changed". modified)
        }
        return modified
    }

    insertTrack(track) {
        return this.tracks.insert(track)    
    }
}


module.exports = {
    MusicDatabase: MusicDatabase
}