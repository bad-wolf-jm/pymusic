const { EventDispatcher } = require("event_dispatcher")

const { CollectionModel, TrackCollectionModel, PlaylistCollectionModel } = require("./collection.js")
const { QueueModel } = require("./queue.js")
const { SessionModel } = require("./session.js")
const { QueryModel, FunctionModel }  = require("./playlist.js")
const { TrackSetModel } = require("./track_set.js")
const { homedir } = require("os")
var path = require('path');


class MusicDatabase extends EventDispatcher {
    constructor(name, root) {
        super()
        this._name = name
        this._path = path.join(root ? root : homedir(), ".pymusic-library", name)
        this.tracks = new TrackCollectionModel(this, path.join(this._path, "library", "tracks.json"))
        this.sessions  = new CollectionModel(path.join(this._path, "library", "sessions.json"))
        this.playlists = new PlaylistCollectionModel(path.join(this._path, "library", "playlists.json"))
        this.state = new CollectionModel(path.join(this._path, "library", "state.json"))
        this.tags = new CollectionModel(path.join(this._path, "library", "tags.json"))
        this.queue = new QueueModel(this, this.state, "queue")
        this.current_session = new SessionModel(this, this.state, "session")

        this.never_played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history == undefined) || (this.history.length == 0)
        }})

        this.played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history != undefined) && (this.history.length > 0)
        }})

        this.suggested = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTracks()
            let played_tracks = await this.current_session.getTracks()
            let idx = {}
            queued_tracks.forEach((e) => {
                if ((e != null) && (e.relations != undefined)) {
                    if (e.relations != undefined) {
                        Object.keys(e.relations).forEach((k) => {idx[k] = true})
                    }
                }
            })
            played_tracks.forEach((e) => {    
                if ((e != null) && (e.relations != undefined)) {
                    if (e.relations != undefined) {
                        Object.keys(e.relations).forEach((k) => {idx[k] = true})
                    }
                }                
            })
            return Object.keys(idx)
        })

        this.unavailable = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTrackIds()
            let played_tracks = await this.current_session.getTrackIds()
            let unavailable_tracks = await this.unavailable_tracks.getTrackIds()
            let idx = {}
            queued_tracks.forEach((x) => {idx[x] = true})
            played_tracks.forEach((x) => {idx[x] = true})
            unavailable_tracks.forEach((x) => {idx[x] = true})
            return Object.keys(idx)
        })

        this.shortlisted_tracks = new TrackSetModel(this, this.state, "shortlist")
        this.unavailable_tracks = new TrackSetModel(this, this.state, "unavailable")

        this.queue.insert_guard = async (track) => {
            let id = track._id
            let queue = await this.queue._getElements()
            let session_tracks = await this.current_session._getElements()
            let unavailable_tracks = await this.unavailable_tracks._getElements()
            return (queue.elements[id] == undefined) && (session_tracks.elements[id] == undefined) && (unavailable_tracks.elements[id] == undefined)
        }
    }


    async initialize() {
        await this.state.d.insert({_id: "queue", elements:{}, ordering:[null]})
        await this.state.d.insert({_id: "session", elements:{}, ordering:[]})
        await this.state.d.insert({_id: "shortlist", elements:{}})
        await this.state.d.insert({_id: "unavailable", elements:{}})
        await this.state.d.insert({_id: "settings", elements:{
            _id: "settings",
            track_gap: 5000,
            audio_devices: {
                "5f95836dec5d92576a4d6bc3b6638916f1e57445a09ab8631694ea92c349c3de": "Built-in Output"
            },
            audio_setup: {
                main_master: "5f95836dec5d92576a4d6bc3b6638916f1e57445a09ab8631694ea92c349c3de",
                main_headset: "5f95836dec5d92576a4d6bc3b6638916f1e57445a09ab8631694ea92c349c3de",
                prelisten: "5f95836dec5d92576a4d6bc3b6638916f1e57445a09ab8631694ea92c349c3de"
            },
            current_track: {
                _id: null,
                current_position: null
            },
            createdAt: {
                $$date: 1547426138075
            },
            updatedAt: {
                $$date: 1547426138075
            }
        
        }})
    }

    getCoverFolder() {
        return path.join(this._path, "covers")
    }

    getTracksFolder() {
        return path.join(this._path, "tracks")
    }


    async discardCurrentSession() {
        this.current_session._setElements([], {})
    }

    async saveCurrentSession(name, location, address) {
        let session_tracks = await this.current_session._getElements()
        let n = await this.sessions.d.insert({
            event: name,
            location: location,
            address: address,
            date_start: new Date(Object.values(session_tracks.elements).map((e) => {
                return e.time_start
            }).reduce((x,y) => {
                return Math.min(x,y)
            })),
            date_end: new Date(Object.values(session_tracks.elements).map((e) => {
                return e.time_end
            }).reduce((x,y) => {
                return Math.min(x,y)
            })),
            ordering: session_tracks.ordering,
            elements: session_tracks.elements
        })
        this.sessions.dispatch("content-changed", Object.values(this.sessions.getAllObjects()))
        for (let i = 0; i < session_tracks.ordering.length - 1; i++) {
            let track = await this.tracks.getElementById(session_tracks.ordering[i])
            let related = await this.tracks.getElementById(session_tracks.ordering[i+1])
            if (track.stats.relations[related._id] != undefined) {
                track.stats.relations[related._id] += 1
            } else {
                track.stats.relations[related._id] = 1
            }
            await this.tracks.setData(track, {"stats.relations": track.stats.relations})
            await this.discardCurrentSession()
        }
    }

    getSettings() {
        return this.state.find({_id: "settings"})
    }

    async getTracksByIds(id_array) {
        let track_objects = await this.tracks.getObjectsByIds(id_array)
        return track_objects
    }

    async getTrackById(id) {
        return (await this.getTracksByIds([id]))[id]
    }

    async duration(id_array) {
        let tracks = await this.getTracksByIds(id_array)
        let dur = 0
        tracks.forEach((track) => {
            dur += (track.stream_end - track.stream_start)
        })
        return dur
    }

    async setTrackData(track, new_data) {
        let [num, modified] = await this.tracks.update(
            {"_id": track._id}, 
            {$set: new_data}, 
            {returnUpdatedDocs: true})
        if (num > 0) {
            this.dispatch("track-metadata-changed". modified)
        }
        return modified
    }

    insertTrack(track) {
        return this.tracks.insert(track)    
    }

    getFileExtension(f_name) {
        return f_name.slice((Math.max(0, f_name.lastIndexOf(".")) || Infinity) + 1);
    }


    async addFile(file_path) {
        let file_metadata = await read_metadata(file_path)
        let new_track = await this.tracks.d.insert({
            metadata: {
                title: file_metadata.title,
                artist: file_metadata.artist,
                album: file_metadata.album,
                genre: file_metadata.genre,
                year: file_metadata.year,
                tags: [],
                color: null,
                comment: file_metadata.comment,            
            },
            track: {
                duration: file_metadata.duration,
                stream_start: 0,
                stream_end: file_metadata.duration,
                bitrate: file_metadata.bit_rate,
                samplerate: file_metadata.samplerate,
                bpm: file_metadata.bpm,
                size: file_metadata.file_size,
            },
            stats: {
                loved: 0,
                rating: 0,
                play_count: 0,
                last_played: null,
                relations: {}
            }
        })
        let trackId = new_track._id
        let track_filename = `${trackId}.${this.getFileExtension(file_path)}`
        await fs.copy(file_path, path.join(this.getTracksFolder(), track_filename))
        await this.tracks.d.update({_id: trackId}, {$set: {"track.filename": track_filename}})

        if (file_metadata.picture != undefined) {
            let image_type = file_metadata.picture.format;
            let extensions = {
                'image/jpeg': 'jpg',
                'image/png': 'png'
            }
            if (image_type in extensions) {
                let image = await Jimp.read(new Buffer(file_metadata.picture.data))
                let ext = extensions[image_type];
                let root = this.getCoverFolder()

                if (image != null) {
                    image.write(`${path.join(root, `${trackId}_original.${ext}`)}`);
                    image.resize(320,320).write(`${path.join(root, `${trackId}_large.${ext}`)}`)
                    image.resize(160,160).write(`${path.join(root, `${trackId}_medium.${ext}`)}`)
                    image.resize(100,100).write(`${path.join(root, `${trackId}_small.${ext}`)}`)   
                    await this.tracks.d.update({_id: trackId}, {$set: {
                        "metadata.cover.original": `${trackId}_original.${ext}`,
                        "metadata.cover.large": `${trackId}_large.${ext}`,
                        "metadata.cover.medium": `${trackId}_medium.${ext}`,
                        "metadata.cover.small": `${trackId}_small.${ext}`
                    }})
                }
            }  
        }
        this.tracks.dispatch("content-changed", await this.tracks.getTracks())
        return this.getTrackById(trackId)

    }
}

module.exports = {
    MusicDatabase: MusicDatabase
}