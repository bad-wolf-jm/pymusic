const { EventDispatcher } = require("event_dispatcher")

const { CollectionModel, TrackCollectionModel, PlaylistCollectionModel } = require("./collection.js")
const { QueueModel } = require("./queue.js")
const { SessionModel } = require("./session.js")
const { QueryModel, FunctionModel }  = require("./playlist.js")
const { TrackSetModel } = require("./track_set.js")

var path = require('path');


class MusicDatabase extends EventDispatcher {
    constructor(name) {
        super()
        this.tracks = new TrackCollectionModel(path.join(".ds", name, "tracks.json"))
        this.playback_logs = new CollectionModel(path.join(".ds", name, "playback_logs.json"))
        this.sessions  = new CollectionModel(path.join(".ds", name, "sessions.json"))
        this.playlists = new PlaylistCollectionModel(path.join(".ds", name, "playlists.json"))
        this.state = new CollectionModel(path.join(".ds", name, "state.json"))
        this.tags = new CollectionModel(path.join(".ds", name, "tags.json"))
        this.queue = new QueueModel(this, this.state, "queue")
        this.current_session = new SessionModel(this, this.state, "session")

        this.never_played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history == undefined) || (this.history.length == 0)
        }})

        this.played_tracks = new QueryModel(this, this.tracks, {$where: function () {
            return (this.history != undefined) && (this.history.length > 0)
        }})

        this.suggested = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTracks()
            let played_tracks = await this.current_session.getTracks()
            let idx = {}
            queued_tracks.forEach((e) => {
                if ((e != null) && (e.relations != undefined)) {
                    if (e.relations != undefined) {
                        Object.keys(e.relations).forEach((k) => {idx[k] = true})
                    }
                }
            })
            played_tracks.forEach((e) => {    
                if ((e != null) && (e.relations != undefined)) {
                    if (e.relations != undefined) {
                        Object.keys(e.relations).forEach((k) => {idx[k] = true})
                    }
                }                
            })
            return Object.keys(idx)
        })

        this.unavailable = new FunctionModel(this, this.tracks, async () => {
            let queued_tracks = await this.queue.getTrackIds()
            console.log(queued_tracks)
            let played_tracks = await this.current_session.getTrackIds()
            let idx = {}
            queued_tracks.forEach((x) => {idx[x] = true})
            played_tracks.forEach((x) => {idx[x] = true})
            return Object.keys(idx)
        })

        this.shortlisted_tracks = new TrackSetModel(this, this.state, "shortlist")
        this.unavailable_tracks = new TrackSetModel(this, this.state, "unavailable")

        this.queue.insert_guard = async (track) => {
            let id = track._id
            let queue = await this.queue._getElements()
            let session_tracks = await this.current_session._getElements()
            let unavailable_tracks = await this.unavailable_tracks._getElements()
            return (queue.elements[id] == undefined) && (session_tracks.elements[id] == undefined) && (unavailable_tracks.elements[id] == undefined)
        }
    }

    async discardCurrentSession() {
        this.current_session._setElements([], {})
    }

    async saveCurrentSession(name, location, address) {
        let session_tracks = await this.current_session._getElements()
        let n = await this.sessions.d.insert({
            event: name,
            location: location,
            address: address,
            date_start: new Date(Object.values(session_tracks.elements).map((e) => {return e.time_start}).reduce(Math.max(x, y))),
            date_end: new Date(Object.values(session_tracks.elements).map((e) => {return e.time_end}).reduce(Math.min(x, y))),
            ordering: session_tracks.ordering,
            elements: session_tracks.elements
        })
        this.sessions.dispatch("content-changed", Object.values(this.sessions.getAllObjects()))
        for (let i = 0; i < session_tracks.ordering.length - 1; i++) {
            let track = await this.tracks.getElementById(session_tracks.ordering[i])
            let related = await this.tracks.getElementById(session_tracks.ordering[i+1])
            if (track.relations[related._id] != undefined) {
                track.relations[related._id] += 1
            } else {
                track.relations[related._id] = 1
            }
            await this.tracks.setData(track, {relations: track.relations})
            await this.discardCurrentSession()
        }
    }

    getSettings() {
        return this.state.find({_id: "settings"})
    }

    getTracksByIds(id_array) {
        return this.tracks.getObjectsByIds(id_array)
    }

    async getTrackById(id) {
        return (await this.getTracksByIds([id]))[id]
    }

    async duration(id_array) {
        let tracks = await this.getTracksByIds(id_array)
        let dur = 0
        tracks.forEach((track) => {
            dur += (track.stream_end - track.stream_start)
        })
        return dur
    }

    async setTrackData(track, new_data) {
        let [num, modified] = await this.tracks.update(
            {"_id": track._id}, 
            {$set: new_data}, 
            {returnUpdatedDocs: true})
        if (num > 0) {
            this.dispatch("track-metadata-changed". modified)
        }
        return modified
    }

    insertTrack(track) {
        return this.tracks.insert(track)    
    }
}

module.exports = {
    MusicDatabase: MusicDatabase
}