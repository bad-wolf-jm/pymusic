const { DOMElement } = require("ui/dom/domelement.js")
const { ColorPicker } = require("ui/popup/colorpicker.js")
const { ScrollArea } = require("ui/dom/scroll_area.js")
const { Dialog } = require("ui/dialog/dialog.js")
const { BoxLayout } = require("ui/layout/box")
const { ConfirmButton, DismissButton } = require("ui/dialog/buttons.js")
const { ClusteredListView } = require('ui/listview/cluster')
const { TextRenderer, NumberRenderer } = require('ui/listview/renderer')


class TagListView extends ClusteredListView {
    constructor() {
        super(document.getElementById("playlist-list-elements"), 
              document.getElementById("playlist-list-scroller"))

        this.setupColumnRenderers()
        this._objectid_to_row_id = {}
        this.forward_content_changed = async (q) => {
            await this.updateContents(q)
        }

        this.forward_object_changed = async (q) => {
            await this.updateElement(q)
        }
    }

    convert_playlist(playlist_element) {
        return {
            id: playlist_element._id,
            name: playlist_element.name,
            count: Object.keys(playlist_element.elements).length
        }
    }

    setupColumnRenderers() {
        this.addColumnRenderer(new TextRenderer({
            width: "30px",
            color: (obj) => {return null},
            text: (obj) => {return ""}
        }))
            
        this.addColumnRenderer(new TextRenderer({
            width: "250px",
            editTag: "name",
            color: (obj) => {return null},
            text: (obj) => {return obj.name}
        }))

        this.addColumnRenderer(new NumberRenderer({
            width: "50px",
            textAlign: "right",
            color: (obj) => {return "rgb(128,128,128)"},
            text: (obj) => {return obj.count}
        }))

        this.addColumnRenderer(new TextRenderer({
            width: "25px",
            textAlign:"center",
            color: (obj) => {return null},
            text: (obj) => {return `<i class="fa fa-trash"></i>`}
        }))
    }


    async handleEditKeypress(e) {
        let new_name = this.editValues['name'].value
        if ((new_name == this.oldName) || (await this.model.checkNameAvailability(new_name))) {
            this.editValues['name'].style.color = null
        } else {
            this.editValues['name'].style.color = "#dd0000"
        }
    }

    beginEdit(id) {
        let rowId = super.beginEdit()
        this.editId = this._elements.getElementById(rowId).id
        this.oldName = this._elements.getElementById(rowId).name
    }

    async saveEdit() {
        let values = super.saveEdit()
        if (await this.model.checkNameAvailability(values.name)) {
            await this.model.renamePlaylist(this.editId, values.name)
        } else {
            this.editValues['name'].style.color = "#dd0000"
        }
    }

    handleContextMenu(e) {
        let tableRow = e.target.closest("tr")
        let playlistObject = this._elements.getElementById(tableRow.id)
        let menu = new ContextMenu(playlistObject, this.model, MDB, this)
        menu.popup()
    }

    handleDoubleClick(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        this.dispatch("row-double-click", trackObject.id)
    }

    handleClick(e) {
        let tableRow = e.target.closest("tr")
        let trackObject = this._elements.getElementById(tableRow.id)
        this.dispatch("row-click", trackObject.id)
        this.selectRow(tableRow.id)
    }

    compare_playlists(a, b) {
        if (!a.name) { return -1 }
        if (!b.name) { return 1 }
        let x = a.name.toLowerCase();
        let y = b.name.toLowerCase();
        if (x < y) { return -1; }
        if (x > y) { return 1; }
        return 0;        
    }    

    setList(list_elements) {
        if (list_elements == undefined) {
            list_elements = []
        }

        list_elements.sort(this.compare_playlists) 

        let rowIds = this.setRows(list_elements.map((e) => {
            return this.convert_playlist(e)
        }))

        this._objectid_to_row_id = {}

        Object.keys(rowIds).forEach((id) => {
            this._objectid_to_row_id[rowIds[id].id] = id
        })
    }

    updateElement(playlistObject) {
        let element = this.convert_playlist(playlistObject)
        let rowId = this._objectid_to_row_id[element.id]
        super.updateElement(rowId, element)
        let row = this._row_elements.getElementById(rowId)
        if (row) {
            row.innerHTML = this.renderRow(rowId, element)
        }
    }


    async updateContents(q) {
        this.setList(q)
    }

    async displayModel(model) {
        if (this.model != undefined) {
            this.model.un("content-changed", this.forward_content_changed) 
            this.model.un("object-updated", this.forward_object_changed)
        }
        if (model) {
            this.model = model
            this.model.on("content-changed", this.forward_content_changed) 
            this.model.on("object-updated", this.forward_object_changed)
            this.updateContents(Object.values(await this.model.getAllObjects()))    
        } else {
            this.setList([])
        }
    }
}




class TagEditDialog extends Dialog {
    constructor(config) {
        super()
        this.setTitle("Edit tags")
        this.setStyle({width:'400px', height:"500px"})

        this.layout = new BoxLayout("vertical", {left:20, right:20, top:20, bottom:20, padding:10})
        this.layout.setStyle({
            position: "absolute",
            top: '0px',
            width: "100%",
            height: "100%"
        })

        let text = new DOMElement("div")
        text.setStyle({
            textAlign: "justify",
            margin: "20px",
            color:"rgb(30,30,30)"
        })
        text.domElement.innerHTML = "Edit, add or remove tags.  Deleting a tag will remove it from all tracks it was assigned to."

        let save_button = new ConfirmButton()
        save_button.setText("Save")
        save_button.on("click", () => {
            this.close()
        })

        let dismiss_button = new DismissButton()
        dismiss_button.setText("Close")
        dismiss_button.on("click", () => {
            this.close()
        })

        let button_layout = new BoxLayout("horizontal", {padding: 20})
        button_layout.append(save_button, true, true)
        button_layout.append(dismiss_button, true, true)
        

        let tagListScroller = new ScrollArea()
        tagListScroller.setStyle({
            overflow: null,
            overflowY: "auto"
        })
        let tagListTable = new DOMElement("table")
        tagListTable.setStyle({

        })
        tagListScroller.appendChild(tagListTable)


        this.layout.append(text, false, false)
        this.layout.append(tagListScroller, true, true)
        this.layout.append(button_layout, false, true, 50)
        this.appendChildren([this.layout])
    }

    async open() {
        super.open()
    }
}

module.exports = {
    TagEditDialog: TagEditDialog
}